<!doctype html>
<html>
  <head>
    <meta charset="UTF-8"/>
  </head>
  <link rel="stylesheet" href="highlight/styles/github-dark.min.css">
  <style>
    code{
      background-color:#D3D3D3;
    }
    .center{
      margin-left:auto;
      margin-right:auto;
      display:block;
    }
    .hr1{
        height:0.5em;background-color:lightgrey;
    }
    .dimdiv{
      position:absolute;
      top:0;
      width:100%;
      pointer-events: none;
    }
    .dimcode{
      background-color:black;
      opacity:0.625;
      width:100%;
      display:block;
    }
    .showcode{
      width:100%;
      opacity:0;
      display:block;
    }
    .readborder{
      border:0.25em solid black;
    }
    .copyborder{
      border:0.5em dashed gray;
    }
    .codeParentDiv{
      position:relative;
      overflow-x:scroll;
    }
  </style>
  <body>
<table style="position:fixed;top:0%;left:0%;width:auto;height:100%;background-color:lightgrey">
      <tr>
        <td style="border: 1px solid black;">
          <span><b>Attention:</b>Repository : <a href="https://github.com/shuffleandko/circle-collision-without-vector">https://github.com/shuffleandko/circle-collision-without-vector</a>. The correctness of this tutorial is not guaranteed, the context may be updated without notifications, and the author is not responsible for any consequences that copy or run the codes in the tutorial, if any.</span>
          <hr/>
          <span><b>Go to chapter: </b></span>
          <select onChange="window.location.href=this.value">
            <option value="chapter_1.html">Chapter 1 : Introduction</option>
            <option value="chapter_2.html">Chapter 2 : Draw something on browsers using canvas element</option>
            <option value="chapter_3.html">Chapter 3 : Move the circle</option>
            <option value="chapter_4.html">Chapter 4 : Circle-circle collision detection</option>
            <option value="chapter_5.html">Chapter 5 : Circle-circle collision response</option>
            <option value="chapter_6.html">Chapter 6 : Use array to avoid repeating codes</option>
            <option value="chapter_7.html">Chapter 7 : Circles and fixed circles collision</option>
            <option value="chapter_8.html" selected disabled>Chapter 8 : Circles and fixed points, lines and fixed polygons collision</option>
            <option value="chapter_9.html">Chapter 9 : Test all objects working together and remove debug drawings</option>
          </select>
          <hr/>
          <button onclick="window.location.href='#top'">▲ Go back to top ▲</button>&nbsp<span><b>Move to section</b>:
            <select onChange="window.location.href=this.value">
              <option value="#section_1">8.1 Add and draw a point</option>
              <option value="#section_2">8.2 Circle and fixed point collision response</option>
              <option value="#section_3">8.3 Add and draw a line segment</option>
              <option value="#section_4">8.4 Line segment collision detection</option>
              <option value="#section_5">8.5 Line segment collision response</option>
              <option value="#section_6">8.6 Refactor the line segment collision code : simplify the formulae and eliminate the square root</option>
              <option value="#section_7">8.7 Multiple (Connected) line segments and circle collision</option>
              <option value="#section_8">8.8 Fixed polygon and circle collision</option>
              <option value="#section_9">8.9 Multiple fixed polygons and circle collision</option>
            </select>
          </span>
        </td>
      </tr>
      <tr style="width:width:100%;height:100%;">
        <td style="width:100%;height:100%;"><div style="background-color:white;overflow-x:auto;overflow-y:scroll;width:width:100%;height:100%;padding-left:0.5em;">
          <div id="top"></div> 
    <h1 style="text-align:center;">Chapter 8 : Circles and fixed points, lines and fixed polygons collision</h1>
    <hr class="hr1"/>
    <h2 id="section_1">8.1 Add and draw a point</h2>
    <p>At former chapters, we implemented circle and fixed circle collisions. Now we would add more fixed objects to the canvas. The collision code of new fixed objects are similar to the collision code of fixed circles. First we would start with 'fixed point'.</p>
    <p>We would start with the following canvas:</p>
<div class="codeParentDiv" style="height:120em"><div class="hljs copyborder" style="position:absolute;">
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && relVx < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && relVx > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
    </div></div>
    <p>The canvas should show only a single circle moving as the following:</p>
    <iframe id="iframe-chapter_8_1_1-1" class="center" src="chapter_8_1_1.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_1_1-1').src+='';">Reload</button>
    <p>Now We would add a fixed point. To be simple, we don't use an array to hold fixed points currently, just define a single fixed point, <code>fp</code> (fixed point):</p>
<div class="codeParentDiv" style="height:8em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">const fp={
  x:45,
  y:60
};</span></code></pre>
    </div></div>
    <p>The fixed circle is similar to fixed circle, but it is simpler because it has no <code>r</code> (radius).</p>
    <p>And we need to add codes to draw the fixed point:</p>
    <div class="codeParentDiv" style="height:9em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">//draw fixed point
ctx.fillStyle=ctx.strokeStyle="gray";
ctx.beginPath();
ctx.arc(canvas.width/2+fp.x,canvas.height/2-fp.y,2,0,2*Math.PI);
ctx.fill();</span></code></pre>
    </div></div>
    <p>We add the codes above into the example:</p>
    <div class="codeParentDiv" style="height:131em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">    const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fp = {
    x:-90,
    y:30
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && relVx < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && relVx > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point
    ctx.fillStyle=ctx.strokeStyle="gray";
    ctx.beginPath();
    ctx.arc(canvas.width/2+fp.x,canvas.height/2-fp.y,2,0,2*Math.PI);
    ctx.fill();

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>Now the canvas would show a moving circle and a static circle:</p> 
    <iframe id="iframe-chapter_8_1_2-1" class="center" src="chapter_8_1_2.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_1_2-1').src+='';">Reload</button>
    <p>Now we may see the movable circle just passes through the fixed point instead of colliding with it, we would add the collision response codees at the next section.</p>
    <hr class="hr1"/>
    <h2 id="section_2">8.2 Circle and fixed point collision response</h2>
    <p><b>fixed points are logically equal to fixed circles with 0 radius!</b> So fixed points are similar to fixed circles, except the <code>r</code> (radius) of a fixed point is 0. Recall the collision detection and response of circles and fixed circles collision :</p>
<div class="codeParentDiv" style="height:16em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">//fixed circle and circle check collision
for(const fc of fixedCircleArray){
  for(const c2 of circleArray){
    const dx=c2.cx-fc.cx;
    const dy=c2.cy-fc.cy;
    const vxFactor = c2.vx * dx + c2.vy * dy;
    if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && relVx < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && relVx > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
      c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
      c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
    }
  }
}</span></code></pre>
    </div></div>
    <p>Fixed points are more simple: <code>r</code> is 0, so we would elimilate <code>fp.r</code> and change the variable name <code>fc</code> to <code>fp</code>:</p>
<div class="codeParentDiv" style="height:13em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">//fixed point and circle check collision
for(const c2 of circleArray){
  const dx=c2.cx-fp.x;
  const dy=c2.cy-fp.y;
  const vxFactor = c2.vx * dx + c2.vy * dy;
  if( dx * dx + dy * dy <= c2.r * c2.r && relVx < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
    c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
    c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
  }
}</span></code></pre>
    </div></div>
    <p>Now we may add the codes above to the canvas:</p>
<div class="codeParentDiv" style="height:140em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fp = {
    x:-90,
    y:30
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed point and circle check collision
    for(const c2 of circleArray){
      const dx=c2.cx-fp.x;
      const dy=c2.cy-fp.y;
      const vxFactor = c2.vx * dx + c2.vy * dy;
      if( dx * dx + dy * dy <= c2.r * c2.r && relVx < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && relVx < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && relVx > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point
    ctx.fillStyle=ctx.strokeStyle="gray";
    ctx.beginPath();
    ctx.arc(canvas.width/2+fp.x,canvas.height/2-fp.y,2,0,2*Math.PI);
    ctx.fill();

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>Now the canvas should show the moving circles rebound when colliding with the fixed point.</p>
    <iframe id="iframe-chapter_8_2_1-1" class="center" src="chapter_8_2_1.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_2_1-1').src+='';">Reload</button>
    <p>Currently the canvas have a single point. But in order to have line segments and fixed polygons, we need to support multiple points!</p>
    <p>So we would modify fp, change the data of <code>x</code> and <code>y</code> from a single number to an array of numbers, also add a new point : <b>(-15,75)</b>, into it:</p>
<div class="codeParentDiv" style="height:8em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">const fp = {
  x:[-90,-15],
  y:[ 30, 75]
};</span></code></pre>
    </div></div>
    <p>Note: We don't use a 2D array like <code>[[-90,30],[-15,75]]</code> because <b>we want the code of accessing each point be shorter and clearer at the formula</b>, ie:accessing x of a point with <code>fp.x[i]</code> instead of <code>fp.p[0][i]</code>.</p>
    <p>Also we need to modify the code of drawing fixed points so that it becomes supporting multiple points:</p>
<div class="codeParentDiv" style="height:11em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//draw fixed point
for(let i=0;i < fp.x.length;i++){
  ctx.fillStyle=ctx.strokeStyle="gray";
  ctx.beginPath();
  ctx.arc(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i],2,0,2*Math.PI);
  ctx.fill();
}</span></code></pre>
    </div></div>
    <p>Add the codes above to the canvas:</p>
<div class="codeParentDiv" style="height:128em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fp = {
    x:[-90,-15],
    y:[ 30, 75]
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed point and circle check collision
    for(let i=0;i < fp.x.length;i++){
      for(const c2 of circleArray){
        const dx=c2.cx-fp.x[i];
        const dy=c2.cy-fp.y[i];
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( dx * dx + dy * dy <= c2.r * c2.r && relVx < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && relVx < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && relVx > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point
    for(let i=0;i < fp.x.length;i++){
      ctx.fillStyle=ctx.strokeStyle="gray";
      ctx.beginPath();
      ctx.arc(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i],2,0,2*Math.PI);
      ctx.fill();
    }

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>

    <iframe id="iframe-chapter_8_2_2-1" class="center" src="chapter_8_2_2.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_2_2-1').src+='';">Reload</button>
    <p>Now the circle collides with 2 fixed points. Next section we would add collision codes of line segment between these 2 points!</p>
    <hr class="hr1"/>
    <h2 id="section_3">8.3 Add and draw a line segment</h2>
    <p>Current we have 2 fixed points, when conneting them with a line, it would form a line segment. Now we would add codes to show the position of fixed points:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">ctx.fillStyle=ctx.strokeStyle="black";
ctx.fillText(fp.x[i].toFixed(1)+","+fp.y[i].toFixed(1),canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);</span></code></pre>
    </div></div>
    <p>Also we would add a new for-loop to draw the line between 2 fixed points:</p>
    <div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">//draw line segment
for(let i=0;i < fp.x.length-1;i++){
  ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
  ctx.lineTo(canvas.width/2+fp.x[i+1],canvas.height/2-fp.y[i+1]);
  ctx.stroke();
}</span></code></pre>
    </div></div>
    <p>Add the codes above to the canvas:</p>
<div class="codeParentDiv" style="height:135em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fp = {
    x:[-90,-15],
    y:[ 30, 75]
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed point and circle check collision
    for(let i=0;i < fp.x.length;i++){
      for(const c2 of circleArray){
        const dx=c2.cx-fp.x[i];
        const dy=c2.cy-fp.y[i];
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( dx * dx + dy * dy <= c2.r * c2.r && vxFactor < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && vxFactor < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && vxFactor > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point
    for(let i=0;i < fp.x.length;i++){
      ctx.beginPath();
      ctx.fillStyle=ctx.strokeStyle="black";
      ctx.fillText(fp.x[i].toFixed(1)+","+fp.y[i].toFixed(1),canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.fillStyle=ctx.strokeStyle="gray";
      ctx.arc(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i],2,0,2*Math.PI);
      ctx.fill();
    }
    //draw line segment
    for(let i=0;i < fp.x.length-1;i++){
      ctx.beginPath();
      ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.lineTo(canvas.width/2+fp.x[i+1],canvas.height/2-fp.y[i+1]);
      ctx.stroke();
    }

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>Now we should see a line connecting 2 fixed points as the following:</p>
    <iframe id="iframe-chapter_8_3_1-1" class="center" src="chapter_8_3_1.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_3_1-1').src+='';">Reload</button>
    <p>Note that this for loop ends at <code>fp.x.length-1</code> instead of <code>fp.x.length</code> because logically <b>line 1 is composed of point 1 and point 2</b>.</p>
    <p>Now the circle just passes through the line and collides with the fixed points, so we would implement the line and circle collision codes at next section.</p>
    <hr class="hr1"/>
    <h2 id="section_4">8.4 Line segment collision detection</h2>
    <p>Now we need to check if a circle overlaps with a line. How can we do that? The solution is similar to <b>1.5D collision</b> at chapter 5 : rotate the canvas so that the line segment becomes vertical!</p>
    <p>First, we need to rotate the whole canvas clockwise so that the line becomes horizontal. Recall the <b>x-y clockwise rotation formula</b>:</p>
    <table style="margin-left:auto;margin-right:auto;">
      <tr><td>x<sub>new</sub> =&nbsp; x cosθ + y sinθ</td></tr>
      <tr><td>y<sub>new</sub> = -x sinθ + y cosθ</td></tr>
    </table>
    <p>When the canvas rotates clockwise so that the line segment becomes horizontal, the canvas becomes the following:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <th>Original canvas</sup></th>
      <th>Line segment becomes horizontal (rotated θ clockwise)</th>
      <tr>
        <td>
          <iframe id="iframe-chapter_8_4_1-1" src="chapter_8_4_1.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
        <td>
          <iframe id="iframe-chapter_8_4_2-1" src="chapter_8_4_2.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
      </tr>
    </table>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_4_1-1').src+='';document.getElementById('iframe-chapter_8_4_2-1').src+='';">Reload</button>
    <p>However, this time, <b>we need the line segment be vertical</b>, so after rotating θ clockwise we need to rotate counter-clockwise 90°, which actually means <b>rotate θ - 90° clockwise</b>, so the rotation formulae becomes:</p>
    <table style="margin-left:auto;margin-right:auto;">
      <tr><td>x<sub>new</sub> =&nbsp; x cos(θ - 90°) + y sin(θ - 90°)</td></tr>
      <tr><td>y<sub>new</sub> = -x sin(θ - 90°) + y cos(θ - 90°)</td></tr>
    </table>
    <p>The following table shows that how the line segment becomes horizontal and then vertical:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <th>Original canvas</sup></th>
      <th>Rotated θ clockwise</th>
      <th>Rotated θ and then -90° clockwise</th>
      <tr>
        <td>
          <iframe id="iframe-chapter_8_4_1-2" src="chapter_8_4_1.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
        <td>
          <iframe id="iframe-chapter_8_4_2-2" src="chapter_8_4_2.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
        <td>
          <iframe id="iframe-chapter_8_4_3-1" src="chapter_8_4_3.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
      </tr>
    </table>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_4_1-2').src+='';document.getElementById('iframe-chapter_8_4_2-2').src+='';document.getElementById('iframe-chapter_8_4_3-1').src+='';">Reload</button>
    <p>First, from the original canvas, we have new variables <code>lx</code> and <code>ly</code> that related to θ:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>sinθ = </b></td>
              <td style="border-bottom:1px solid;">ly</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>cosθ = </b></td>
              <td style="border-bottom:1px solid;">lx</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    <p>For angle θ - 90°, we have another formulae:</p>
    <table style="margin-left:auto;margin-right:auto;">
      <tr><td>sin (θ - 90°) =&nbsp;-&nbsp;cosθ</td></tr>
      <tr><td>cos (θ - 90°) =&nbsp; &nbsp;sinθ</td></tr>
    </table>
    <p>So, by replacing sin(θ - 90°) and cos(θ - 90°) formulae with corresponding sinθ and cosθ formulae above, <b>the formulae to find x and y of fixed points after rotating the canvas until the line segment becomes vertical</b> is:</p>
    <table style="margin-left:auto;margin-right:auto;">
      <tr><td>x<sub>new</sub> = x sinθ - y cosθ</td></tr>
      <tr><td>y<sub>new</sub> = x cosθ + y sinθ</td></tr>
    </table>
    <p>At chapter 5, we know that we don't need to find θ first, but replace sinθ and cosθ with another formulae directly. So by replace sinθ and cosθ with the formulae of <code>lx</code> and <code>ly</code> above, the formulae becomes:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>x<sub>new</sub> = </b></td>
              <td style="border-bottom:1px solid;">x * ly - y * lx</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>y<sub>new</sub> = </b></td>
              <td style="border-bottom:1px solid;">x * lx + y * ly</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    <p>Replacing the variable names with the names that we use in the code, the formulae to find the position of fixed points after rotation:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>x1 = </b></td>
              <td style="border-bottom:1px solid;">fp.x[i] * ly - fp.y[i] * lx</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>y1 = </b></td>
              <td style="border-bottom:1px solid;">fp.x[i] * lx + fp.y[i] * ly</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
    <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>x2 = </b></td>
              <td style="border-bottom:1px solid;">fp.x[i+1] * ly - fp.y[i+1] * lx</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>y2 = </b></td>
              <td style="border-bottom:1px solid;">fp.x[i+1] * lx + fp.y[i+1] * ly</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
    <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>cx = </b></td>
              <td style="border-bottom:1px solid;">c2.cx * ly - c2.cy * lx</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>cy = </b></td>
              <td style="border-bottom:1px solid;">c2.cx * lx + c2.cy * ly</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    <p>Now we may start coding! To check the collision between a circle and a line segment, first we define new variable: <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>, which represent <b>the new x-y positions of the tip of the line segment after rotation</b>:</p>
    <div class="codeParentDiv" style="height:12em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
  const x2 = (fp.x[i+1] * ly - fp.y[i+1] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
}</span></code></pre>
    </div></div>
    <p>After the line segment becomes vertical, the case is <b>similar to 1.5D collison</b>.</p>
    <p>Reminder, our target is to check if the circle touches the line segment! How can we check that? The answer is: check <b>if the circle touches the x position of the vertical line segment</b>, shown as the following:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <th>Circle comes from right</th>
      <th>Circle comes from left</th>
      <tr>
        <td>
          <iframe id="iframe-chapter_8_4_4-1" src="chapter_8_4_4.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
        <td>
          <iframe id="iframe-chapter_8_4_5-1" src="chapter_8_4_5.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
      </tr>
    </table>
    <p>As <b>the circle may comes from both sides of the line segment, so we have 2 cases as above</b>. From the canvas above, we may know the condition of the circle touches the line segment is: <code>cx - r <= x1</code> or <code>cx + r >= x1</code>. Add the condition with the for-loop into the code:</p>
    <div class="codeParentDiv" style="height:17em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
  const x2 = (fp.x[i+1] * ly - fp.y[i+1] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
  for(const c2 of circleArray){
    const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
    if(cx - c2.r <= x1 || cx + c2.r >= x1){
    }
  }
}</span></code></pre>
    </div></div>
    <p>However, besides the conditions above, there is one more condition need to fulfill when the circle is touching the line segment: <b>The y position of circle must be between the start and the end of the line</b>, shown as the following:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <th>Circle comes from right</th>
      <th>Circle comes from left</th>
      <tr>
        <td>
          <iframe id="iframe-chapter_8_4_6-1" src="chapter_8_4_6.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
        <td>
          <iframe id="iframe-chapter_8_4_7-1" src="chapter_8_4_7.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
      </tr>
    </table>
    <p>So 2 more conditions to add: <code>y1 < cy && cy < y2</code>:</p>
    <div class="codeParentDiv" style="height:20em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
  const x2 = (fp.x[i+1] * ly - fp.y[i+1] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
  for(const c2 of circleArray){
    const cy = (c2.cx * lx + c2.cy * ly) / Math.sqrt(lx * lx + ly * ly);
    if(y1 < cy && cy < y2){
      const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
      if(cx - c2.r <= x1 || cx + c2.r >= x1){
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Now we may test the collision code! We would stop the circle when it collides with the line segment, by adding <code>intervalId</code> and <code>stopInterval(intervalId)</code>:</p>
<div class="codeParentDiv" style="height:30em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">.
.
.
const intervalId=setInterval(function(){
.
.
.
//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
  const x2 = (fp.x[i+1] * ly - fp.y[i+1] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
  for(const c2 of circleArray){
    const cy = (c2.cx * lx + c2.cy * ly) / Math.sqrt(lx * lx + ly * ly);
    if(y1 < cy && cy < y2){
      const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
      if(cx - c2.r <= x1 || cx + c2.r >= x1){
        clearInterval(intervalId);
      }
    }
  }
}
.
.
.</span></code></pre>
    </div></div>
    <p>Add the codes above into the canvas:</p>
<div class="codeParentDiv" style="height:169em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fp = {
    x:[-90,-15],
    y:[ 30, 75]
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  const intervalId=setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed point and circle check collision
    for(let i=0;i < fp.x.length;i++){
      for(const c2 of circleArray){
        const dx=c2.cx-fp.x[i];
        const dy=c2.cy-fp.y[i];
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( dx * dx + dy * dy <= c2.r * c2.r && relVx < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }
    //line segment and circle collision
    for(let i=0;i < fp.x.length-1;i++){
      const lx = fp.x[i+1] - fp.x[i];
      const ly = fp.y[i+1] - fp.y[i];
      const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
      const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
      const x2 = (fp.x[i+1] * ly - fp.y[i+1] * lx) / Math.sqrt(lx * lx + ly * ly);
      const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
      for(const c2 of circleArray){
        const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
        const cy = (c2.cx * lx + c2.cy * ly) / Math.sqrt(lx * lx + ly * ly);
        if(y1 < cy && cy < y2){
          if(cx - c2.r <= x1 || cx + c2.r >= x1){
            clearInterval(intervalId);
          }
        }
      }
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && relVx < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && relVx > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point
    for(let i=0;i < fp.x.length;i++){
      ctx.beginPath();
      ctx.fillStyle=ctx.strokeStyle="black";
      ctx.fillText(fp.x[i].toFixed(1)+","+fp.y[i].toFixed(1),canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.fillStyle=ctx.strokeStyle="gray";
      ctx.arc(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i],2,0,2*Math.PI);
      ctx.fill();
    }
    //draw line segment
    for(let i=0;i < fp.x.length-1;i++){
      ctx.beginPath();
      ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.lineTo(canvas.width/2+fp.x[i+1],canvas.height/2-fp.y[i+1]);
      ctx.stroke();
    }

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>Now the circle should stop immediately when touching the line segment... But not really:</p>
    <iframe id="iframe-chapter_8_4_8-1" class="center" src="chapter_8_4_8.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_4_8-1').src+='';">Reload</button>
    <p>Why? Because we missed some conditions to add! When rotating the case above until the line segment becomes vertical, the circle stops at the position shown at the following:</p>
    <iframe class="center" src="chapter_8_4_9.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <p>Ideally, we expect the circle stops when <code>cx - c2.r < x1</code>:</p>
    <iframe class="center" src="chapter_8_4_6.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <p>However, another condition : <code>cx + c2.r > x1</code>, also take effect at our case:</p>
    <iframe class="center" src="chapter_8_4_9.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <p>In other words, <b>currently the cases below are logically the same at our code</b>:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <th>Circle comes from right</th>
      <th>Circle comes from left</th>
      <tr>
        <td>
          <iframe id="iframe-chapter_8_4_9-1" src="chapter_8_4_9.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
        <td>
          <iframe id="iframe-chapter_8_4_7-1" src="chapter_8_4_7.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
      </tr>
    </table>
    <p>How can we fix the code? The answer is :<b>Add extra conditions: each condition only takes effect when the circle is at correct side of line segment only</b>! Review the case again:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <th>Circle comes from right (cx > x1)</th>
      <th>Circle comes from left (cx < x1)</th>
      <tr>
        <td>
          <iframe id="iframe-chapter_8_4_4-1" src="chapter_8_4_4.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
        <td>
          <iframe id="iframe-chapter_8_4_5-1" src="chapter_8_4_5.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
      </tr>
    </table>
    <p>So, <code>cx - c2.r < x1</code> should combine with <code>cx > x1</code> and <code>cx + c2.r > x1</code> should combine with <code>cx < x1</code>, the condition becomes:</p>
<div class="codeParentDiv" style="height:5em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">if( (cx > x1 && cx - c2.r <= x1) || (cx < x1 && cx + c2.r >= x1)){</span></code></pre>
    </div></div>
    <p>Modify the x position checking condition as the following:</p>
<div class="codeParentDiv" style="height:169em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fp = {
    x:[-90,-15],
    y:[ 30, 75]
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  const intervalId=setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed point and circle check collision
    for(let i=0;i < fp.x.length;i++){
      for(const c2 of circleArray){
        const dx=c2.cx-fp.x[i];
        const dy=c2.cy-fp.y[i];
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( dx * dx + dy * dy <= c2.r * c2.r && relVx < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }
    //line segment and circle collision
    for(let i=0;i < fp.x.length-1;i++){
      const lx = fp.x[i+1] - fp.x[i];
      const ly = fp.y[i+1] - fp.y[i];
      const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
      const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
      const x2 = (fp.x[i+1] * ly - fp.y[i+1] * lx) / Math.sqrt(lx * lx + ly * ly);
      const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
      for(const c2 of circleArray){
        const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
        const cy = (c2.cx * lx + c2.cy * ly) / Math.sqrt(lx * lx + ly * ly);
        if(y1 < cy && cy < y2){
          if( (cx > x1 && cx - c2.r <= x1) || (cx < x1 && cx + c2.r >= x1)){
            clearInterval(intervalId);
          }
        }
      }
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && relVx < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && relVx > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point
    for(let i=0;i < fp.x.length;i++){
      ctx.beginPath();
      ctx.fillStyle=ctx.strokeStyle="black";
      ctx.fillText(fp.x[i].toFixed(1)+","+fp.y[i].toFixed(1),canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.fillStyle=ctx.strokeStyle="gray";
      ctx.arc(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i],2,0,2*Math.PI);
      ctx.fill();
    }
    //draw line segment
    for(let i=0;i < fp.x.length-1;i++){
      ctx.beginPath();
      ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.lineTo(canvas.width/2+fp.x[i+1],canvas.height/2-fp.y[i+1]);
      ctx.stroke();
    }

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>Now circle should stop in front of the line segment:</p>
    <iframe id="iframe-chapter_8_4_10-1" class="center" src="chapter_8_4_10.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_4_10-1').src+='';">Reload</button>
    <p>Great, we finished line segment collision checking implementation! At next section we would add the collision response code of the line segment!</p>
    <hr class="hr1"/>
    <h2 id="section_5">8.5 Line segment collision response</h2>
    <p>Now we would implement the collision response of line segments! The first thing to add is <b>avoid separating collision</b> stated in chapter 5. We need to ensure collision formulae is applied only when the circle is approaching to the line segment instead of leaving it.</p>
    <p>For circle comes from right : <code>(cx > x1 && cx - c2.r <= x1)</code>, we need to add <code>vx < 0</code>, and when the circle comes from left : <code>(cx < x1 && cx + c2.r >= x1)</code>, we need to add <code>vx > 0</code>. The following canvas shows the condition in clearer way:</p> 
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <th>Circle comes from right (vx < 0)</th>
      <th>Circle comes from left (vx > 0)</th>
      <tr>
        <td>
          <iframe id="iframe-chapter_8_5_1-1" src="chapter_8_5_1.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
        <td>
          <iframe id="iframe-chapter_8_5_2-1" src="chapter_8_5_2.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
      </tr>
    </table>
    <p>Like other points before, the <code>vx</code> of the circle (new <code>c2.vx</code> after the line segment is rotated to be vertical) is found by the formulae below:</p>
    <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>vx = </b></td>
              <td style="border-bottom:1px solid;">c2.vx * ly - c2.vy * lx</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
    <p>So we add the conditions to the collision checking code:</p>
<div class="codeParentDiv" style="height:22em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
  const x2 = (fp.x[i+1] * ly - fp.y[i+1] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
  for(const c2 of circleArray){
    const cy = (c2.cx * lx + c2.cy * ly) / Math.sqrt(lx * lx + ly * ly);
    if(y1 < cy && cy < y2){
      const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
      const vx = (c2.vx * ly - c2.vy * lx) / Math.sqrt(lx * lx + ly * ly);
      if((cx > x1 && cx - c2.r <= x1 && vx < 0) || (cx < x1 && cx + c2.r >= x1 && vx > 0)){
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Now the main problem comes : how to handle the collision between the circle and line segments?</p>
    <p>The answer is : <b>assume the circle is colliding with a point on a line segment</b>:</p>
    <iframe class="center" src="chapter_8_5_3.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <p>From the canvas above, we may know that the collision point occurs at <code>x1 , cy</code>. However, it is at the rotated canvas, we need to know the corrsponding coordinate at original canvas, calling it <code>px</code> and <code>py</code>:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <th>Collision point at 1.5D collision</th>
      <th>Collision point at original case</th>
      <tr>
        <td>
          <iframe id="iframe-chapter_8_5_3-1" src="chapter_8_5_3.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
        <td>
          <iframe id="iframe-chapter_8_5_4-1" src="chapter_8_5_4.html" width="400px" height="400" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
        </td>
      </tr>
    </table>
    <p>Instead of clockwise rotation, this time we need <b>counter-clockwise rotation formulae</b>. Recall the formulae:</p>
    <table style="margin-left:auto;margin-right:auto;">
      <tr><td>x<sub>new</sub> = x cosθ - y sinθ</td></tr>
      <tr><td>y<sub>new</sub> = x sinθ + y cosθ</td></tr>
    </table>
    <p>This time, we need to rotate the collision point θ - 90° counter-clockwise in order to find the position at original case, so the formulae becomes:</p>
    <table style="margin-left:auto;margin-right:auto;">
      <tr><td>x<sub>new</sub> = x cos(θ - 90°) - y sin(θ - 90°)</td></tr>
      <tr><td>y<sub>new</sub> = x sin(θ - 90°) + y cos(θ - 90°)</td></tr>
    </table>
    <p>Replace the (θ - 90°) term, the formulae become:</p>
    <table style="margin-left:auto;margin-right:auto;">
      <tr><td>x<sub>new</sub> =  x sinθ + y cosθ</td></tr>
      <tr><td>y<sub>new</sub> = -x cosθ + y sinθ</td></tr>
    </table>
    <p>Recall the formulae of <code>x1</code> and <code>cy</code>:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>x1 = </b></td>
              <td style="border-bottom:1px solid;">fp.x[i] * ly - fp.y[i] * lx</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>cy = </b></td>
              <td style="border-bottom:1px solid;">c2.cx * lx + c2.cy * ly</td>
            </tr>
            <tr>
             <td>√<span style="border-top:1px solid;">lx * lx + ly * ly</span></td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    <p>The formulae becomes:</p>
    <table style="margin-left:auto;margin-right:auto;">
      <tr><td>x<sub>new</sub> =  x1 * sinθ + cy * cosθ</td></tr>
      <tr><td>y<sub>new</sub> = -x1 * cosθ + cy * sinθ</td></tr>
    </table>
    <p>Put <code>x1</code>, <code>cy</code>, sinθ and cosθ into the formulae:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;">
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>px = </b></td>
              <td style="border-bottom:1px solid;">(fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx</td>
            </tr>
            <tr>
             <td>lx * lx + ly * ly</td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>
          <table style="margin-left:auto;margin-right:auto;text-align:center;">
            <tr>
              <td rowspan="2"><b>py = </b></td>
              <td style="border-bottom:1px solid;">-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly</td>
            </tr>
            <tr>
             <td>lx * lx + ly * ly</td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    <p>Now we may put <code>px</code> and <code>py</code> into the code:</p>
<div class="codeParentDiv" style="height:23em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
  const x2 = (fp.x[i+1] * ly - fp.y[i+1] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
  for(const c2 of circleArray){
    const cy = (c2.cx * lx + c2.cy * ly) / Math.sqrt(lx * lx + ly * ly);
    if(y1 < cy && cy < y2){
      const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
      const vx = (c2.vx * ly - c2.vy * lx) / Math.sqrt(lx * lx + ly * ly);
      if((cx > x1 && cx - c2.r <= x1 && vx < 0) || (cx < x1 && cx + c2.r >= x1 && vx > 0)){
        const px=((fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx) / (lx * lx + ly * ly);
        const py=(-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly) / (lx * lx + ly * ly);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Now <b>px</b> and <b>py</b> is the collision point, recall the collision response of a fixed point:</p>
<div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx=c2.cx-fc.cx;
const dy=c2.cy-fc.cy;
const vxFactor = c2.vx * dx + c2.vy * dy;
if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && relVx < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && relVx > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
  c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
  c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
}</span></code></pre>
    </div></div>
    <p>This time <code>fc.cx</code> is px, and <code>fc.cy</code> is py, so we just replace them and take away the checking collision, it becomes the collision response of fixed point <code>px,py</code>:</p>
<div class="codeParentDiv" style="height:8em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx=c2.cx-px;
const dy=c2.cy-py;
const vxFactor = c2.vx * dx + c2.vy * dy;
c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);</span></code></pre>
    </div></div>
    <p>We found that <code>x2</code> and <code>cy</code> is never in use, so we may delete them from the code. The complete collision respone code becomes:</p>
<div class="codeParentDiv" style="height:26em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
  const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
  for(const c2 of circleArray){
    const cy = (c2.cx * lx + c2.cy * ly) / Math.sqrt(lx * lx + ly * ly);
    if(y1 < cy && cy < y2){
      const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
      const vx = (c2.vx * ly - c2.vy * lx) / Math.sqrt(lx * lx + ly * ly);
      if((cx > x1 && cx - c2.r <= x1 && vx < 0) || (cx < x1 && cx + c2.r >= x1 && vx > 0)){
        const px = ((fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx) / (lx * lx + ly * ly)
        const py = (-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly) / (lx * lx + ly * ly)
        const dx = c2.cx-px;
        const dy = c2.cy-py;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Replace the old line segment and circle collision code with the new one at above:</p>
<div class="codeParentDiv" style="height:174em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fp = {
    x:[-90,-15],
    y:[ 30, 75]
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  const intervalId=setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed point and circle check collision
    for(let i=0;i < fp.x.length;i++){
      for(const c2 of circleArray){
        const dx=c2.cx-fp.x[i];
        const dy=c2.cy-fp.y[i];
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( dx * dx + dy * dy <= c2.r * c2.r && relVx < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }
    //line segment and circle collision
    for(let i=0;i < fp.x.length-1;i++){
      const lx = fp.x[i+1] - fp.x[i];
      const ly = fp.y[i+1] - fp.y[i];
      const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
      const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
      const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
      for(const c2 of circleArray){
        const cy = (c2.cx * lx + c2.cy * ly) / Math.sqrt(lx * lx + ly * ly);
        if(y1 < cy && cy < y2){
          const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
          const vx = (c2.vx * ly - c2.vy * lx) / Math.sqrt(lx * lx + ly * ly);
          if((cx > x1 && cx - c2.r <= x1 && vx < 0) || (cx < x1 && cx + c2.r >= x1 && vx > 0)){
            const px = ((fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx) / (lx * lx + ly * ly)
            const py = (-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly) / (lx * lx + ly * ly)
            const dx = c2.cx-px;
            const dy = c2.cy-py;
            const vxFactor = c2.vx * dx + c2.vy * dy;
            c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
            c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
          }
        }
      }
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && relVx < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && relVx > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point
    for(let i=0;i < fp.x.length;i++){
      ctx.beginPath();
      ctx.fillStyle=ctx.strokeStyle="black";
      ctx.fillText(fp.x[i].toFixed(1)+","+fp.y[i].toFixed(1),canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.fillStyle=ctx.strokeStyle="gray";
      ctx.arc(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i],2,0,2*Math.PI);
      ctx.fill();
    }
    //draw line segment
    for(let i=0;i < fp.x.length-1;i++){
      ctx.beginPath();
      ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.lineTo(canvas.width/2+fp.x[i+1],canvas.height/2-fp.y[i+1]);
      ctx.stroke();
    }

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>Now the circle rebounds when colliding with the line segment:</p>
    <iframe id="iframe-chapter_8_5_5-1" class="center" src="chapter_8_5_5.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_5_5-1').src+='';">Reload</button>
    <hr class="hr1"/>
    <h2 id="section_6">8.6 Refactor the line segment collision code : simplify the formulae and eliminate the square root</h2>
    <p>The line segment and circle collision code constructed before is very raw : there may have some ways to simplify it, also the square root may also be eliminated. So let's simplify the code! Recall the code before:</p>
<div class="codeParentDiv" style="height:26em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
  const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
  for(const c2 of circleArray){
    const cy = (c2.cx * lx + c2.cy * ly) / Math.sqrt(lx * lx + ly * ly);
    if(y1 < cy && cy < y2){
      const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
      const vx = (c2.vx * ly - c2.vy * lx) / Math.sqrt(lx * lx + ly * ly);
      if((cx > x1 && cx - c2.r <= x1 && vx < 0) || (cx < x1 && cx + c2.r >= x1 && vx > 0)){
        const px = ((fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx) / (lx * lx + ly * ly)
        const py = (-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly) / (lx * lx + ly * ly)
        const dx = c2.cx-px;
        const dy = c2.cy-py;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>First, we may take away <code>/ Math.sqrt(lx * lx + ly * ly)</code> at <code>vx</code>:</p>
<div class="codeParentDiv" style="height:4em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const vx = c2.vx * ly - c2.vy * lx;</span></code></pre>
    </div></div>
    <p>Why? Because <b>when checking a / b > 0 , if b > 0, we may multiply both sides by b : a / b * b > 0 * b, which becomes a > 0!</b> So we may <b>multiply both sides by</b> <code>Math.sqrt(lx * lx + ly * ly)</code>, so that the checking becomes <code>vx > 0</code>! The case is similar for <code>vx < 0</code>. So we can take away the <code>Math.sqrt(lx * lx + ly * ly)</code> at <code>vx</code> directly. So <code>vx</code> becomes <code>c2.vx * ly - c2.vy * lx</code> after the square root is taken away. Then the code becomes:</p>
<div class="codeParentDiv" style="height:27em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y1 = (fp.x[i] * lx + fp.y[i] * ly) / Math.sqrt(lx * lx + ly * ly);
  const y2 = (fp.x[i+1] * lx + fp.y[i+1] * ly) / Math.sqrt(lx * lx + ly * ly);
  for(const c2 of circleArray){
    const cy = (c2.cx * lx + c2.cy * ly) / Math.sqrt(lx * lx + ly * ly);
    if(y1 < cy && cy < y2){
      const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
      const vx = c2.vx * ly - c2.vy * lx;
      if((cx > x1 && cx - c2.r <= x1 && vx < 0) || (cx < x1 && cx + c2.r >= x1 && vx > 0)){
        const px = ((fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx) / (lx * lx + ly * ly);
        const py = (-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly) / (lx * lx + ly * ly);
        const dx = c2.cx-px;
        const dy = c2.cy-py;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Next, see the condition <code>if(y1 < cy && cy < y2){</code>, we may see <code>y1</code>, <code>y2</code> and <code>cy</code> contains <code>/ Math.sqrt(lx * lx + ly * ly)</code>, we can multiply both sides by <code>/ Math.sqrt(lx * lx + ly * ly)</code> so that <code>/ Math.sqrt(lx * lx + ly * ly)</code> at both sides are cancelled, so we can take away <code>/ Math.sqrt(lx * lx + ly * ly)</code> from these 3 variables directly:</p>
<div class="codeParentDiv" style="height:27em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  const y1 = fp.x[i] * lx + fp.y[i] * ly;
  const y2 = fp.x[i+1] * lx + fp.y[i+1] * ly;
  for(const c2 of circleArray){
    const cy = c2.cx * lx + c2.cy * ly;
    if(y1 < cy && cy < y2){
      const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
      const relVx = c2.vx * ly - c2.vy * lx;
      if((cx > x1 && cx - c2.r <= x1 && relVx < 0) || (cx < x1 && cx + c2.r >= x1 && relVx > 0)){
        const px = ((fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx) / (lx * lx + ly * ly);
        const py = (-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly) / (lx * lx + ly * ly);
        const dx = c2.cx-px;
        const dy = c2.cy-py;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Next, we would eliminate <code>y1</code>, <code>y2</code> and <code>cy</code>. We would rewrite the condition <code>y1 < cy && cy < y2</code> into <code>cy - y1 > 0 && cy - y2 < 0</code>.</p>
    <p>To eliminate <code>y1</code>, <code>y2</code> and <code>cy</code>, we may <b>put the formulae of</b> <b>into</b> <code>y1 < cy && cy < y2</code> <b>directly</b>:</p>
<div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//if(y1 < cy && cy < y2){
if((c2.cx * lx + c2.cy * ly) - (fp.x[i] * lx + fp.y[i] * ly) > 0 && (c2.cx * lx + c2.cy * ly) - (fp.x[i+1] * lx + fp.y[i+1] * ly) < 0){
.
.
.
}</span></code></pre>
    </div></div>
    <p>Group the like terms:</p>
<div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//if(y1 < cy && cy < y2){
if((c2.cx - fp.x[i]) * lx + (c2.cy - fp.y[i]) * ly > 0 && (c2.cx - fp.x[i+1]) * lx + (c2.cy - fp.y[i+1]) * ly) < 0){
.
.
.
}</span></code></pre>
    </div></div>
    <p>Move some terms to right hand side to eliminate the '> 0':</p>
<div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//if(y1 < cy && cy < y2){
if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
.
.
.
}</span></code></pre>
    </div></div>
    <p>The code becomes:</p>
<div class="codeParentDiv" style="height:24em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
      const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
      const relVx = c2.vx * ly - c2.vy * lx;
      if((cx > x1 && cx - c2.r <= x1 && relVx < 0) || (cx < x1 && cx + c2.r >= x1 && relVx > 0)){
        const px = ((fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx) / (lx * lx + ly * ly);
        const py = (-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly) / (lx * lx + ly * ly);
        const dx = c2.cx-px;
        const dy = c2.cy-py;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Then we would refactor condition:</p>
<div class="codeParentDiv" style="height:8em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">if((cx > x1 && cx - c2.r <= x1 && relVx < 0) || (cx < x1 && cx + c2.r >= x1 && relVx > 0)){
.
.
.
}</span></code></pre>
    </div></div>
    <p>First, we rewrite <code>cx > x1</code> as <code>cx - x1 > 0</code> at left hand side, also rewrite <code>cx < x1</code> as <code>0 < x1 - cx</code>:</p>
    <p>Consider the conditions inside:</p>
<div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//if((cx > x1 && cx - c2.r <= x1 && relVx < 0) || (cx < x1 && cx + c2.r >= x1 && relVx > 0)){
if((cx - x1 > 0 && cx - c2.r <= x1 && relVx < 0) || (0 < x1 - cx && cx + c2.r >= x1 && relVx > 0)){
.
.
.
}</span></code></pre>
    </div></div>
    <p>And then rewrite <code>cx - c2.r <= x1</code> as <code>cx - x1 <= c2.r</code> at left hand side, also rewrite <code>cx + c2.r >= x1</code> as <code>c2.r >= x1 - cx</code> at right hand side, then the conditions become:</p>
<div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//if((cx - x1 > 0 && cx - c2.r <= x1 && relVx < 0) || (0 < x1 - cx && cx + c2.r >= x1 && relVx > 0)){
if((cx - x1 > 0 && cx - x1 <= c2.r && relVx < 0) || (0 < x1 - cx &&  c2.r >= x1 - cx && relVx > 0)){
.
.
.
}</span></code></pre>
    </div></div>
    <p>At <b>left hand side</b>, when <code>cx - x1 > 0</code>, we can square both sides at <code>cx - x1 <= c2.r</code> and be rewritten as <code>(cx - x1) * (cx - x1) <= c2.r * c2.r</code>. Note : <b>a < b doesn't automatically implys a<sup>2</sup> < b<sup>2</sup> (eg: -3 < 2 but (-3)<sup>2</sup> > 2<sup>2</sup>), it implys only when a > 0.</b></p>
    <p>Similarly, at <b>right hand side</b>, when <code>0 < x1 - cx</code>, we can square both sides at <code>c2.r >= x1 - cx</code> and be rewritten as <code>c2.r * c2.r >= (x1 - cx) * (x1 - cx)</code>:</p>
<div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//if((cx - x1 > 0 && cx - x1 <= c2.r && relVx < 0) || (0 < x1 - cx &&  c2.r >= x1 - cx && relVx > 0)){
if((cx - x1 > 0 && (cx - x1) * (cx - x1) <= c2.r * c2.r && relVx < 0) || (0 < x1 - cx &&  c2.r * c2.r >= (x1 - cx) * (x1 - cx) && relVx > 0)){
.
.
.
}</span></code></pre>
    </div></div>
    <p>Additionally, <code>(x1 - cx) * (x1 - cx)</code> equals to <code>(cx - x1) * (cx - x1)</code>, so we may rewrite the condition at right hand side as <code>c2.r * c2.r >= (cx - x1) * (cx - x1)</code>:</p>
<div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//if((cx - x1 > 0 && (cx - x1) * (cx - x1) <= c2.r * c2.r && relVx < 0) || (0 < x1 - cx &&  c2.r * c2.r >= (x1 - cx) * (x1 - cx) && relVx > 0)){
if((cx - x1 > 0 && (cx - x1) * (cx - x1) <= c2.r * c2.r && relVx < 0) || (0 < x1 - cx &&  c2.r * c2.r >= (cx - x1) * (cx - x1) && relVx > 0)){
.
.
.
}</span></code></pre>
    </div></div>
    <p>Wait... we may see <code>(cx - x1) * (cx - x1) <= c2.r * c2.r</code> at left hand side is equal to <code>c2.r * c2.r >= (cx - x1) * (cx - x1)</code> at right hand sides actually! So both sides can now share the same condition: <code>(cx - x1) * (cx - x1) <= c2.r * c2.r</code>, the code becomes:</p>
<div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//if((cx - x1 > 0 && (cx - x1) * (cx - x1) <= c2.r * c2.r && relVx < 0) || (0 > cx - x1 &&  c2.r * c2.r >= (cx - x1) * (cx - x1) && relVx > 0)){
if(((cx - x1 > 0 && relVx < 0) || (0 > cx - x1 && relVx > 0)) && (cx - x1) * (cx - x1) <= c2.r * c2.r){
.
.
.
}</span></code></pre>
    </div></div>
    <p>The code becomes:</p>
<div class="codeParentDiv" style="height:24em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx) / Math.sqrt(lx * lx + ly * ly);
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
      const cx = (c2.cx * ly - c2.cy * lx) / Math.sqrt(lx * lx + ly * ly);
      const relVx = c2.vx * ly - c2.vy * lx;
      if(((cx - x1 > 0 && relVx < 0) || (0 > cx - x1 && relVx > 0)) && (cx - x1) * (cx - x1) <= c2.r * c2.r){
        const px = ((fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx) / (lx * lx + ly * ly);
        const py = (-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly) / (lx * lx + ly * ly);
        const dx = c2.cx-px;
        const dy = c2.cy-py;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Next, we may take away the <code>/ Math.sqrt(lx * lx + ly * ly)</code> of <code>cx</code> and <code>x1</code>, then <code>cx - x1 > 0</code> and <code>0 < x1 - cx</code> keeps unchanged.</p> 
    <p>However, the condition <code>(cx - x1) * (cx - x1)</code> becomes <code>(cx - x1) / Math.sqrt(lx * lx + ly * ly) * (cx - x1) / Math.sqrt(lx * lx + ly * ly)</code>. Combine 2 square roots, it becomes : <code>(cx - x1) * (cx - x1) / (lx * lx + ly * ly)</code>.</p>
    <p>Then we can throw <code>/ (lx * lx + ly * ly)</code> to another side of the condition:</p>
<div class="codeParentDiv" style="height:10em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//if((cx - x1 > 0 && relVx < 0) || (0 > cx - x1 && relVx > 0)) && (cx - x1) * (cx - x1) <= c2.r * c2.r){
if(((cx - x1 > 0 && relVx < 0) || (0 > cx - x1 && relVx > 0)) && (cx - x1) * (cx - x1) <= c2.r * c2.r * (lx * lx + ly * ly)){
.
.
.
}</span></code></pre>
    </div></div>
    <p>Rewrite the whole condition as above:</p>
<div class="codeParentDiv" style="height:24em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  const x1 = (fp.x[i] * ly - fp.y[i] * lx);
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
      const cx = (c2.cx * ly - c2.cy * lx);
      const relVx = c2.vx * ly - c2.vy * lx;
      if(((cx - x1 > 0 && relVx < 0) || (0 > cx - x1 && relVx > 0)) && (cx - x1) * (cx - x1) <= c2.r * c2.r * (lx * lx + ly * ly)){
        const px = ((fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx) / (lx * lx + ly * ly);
        const py = (-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly)  / (lx * lx + ly * ly);
        const dx = c2.cx-px;
        const dy = c2.cy-py;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>And then, we may see <code>cx - x1</code> occurs frequently, we may use a new variable : <code>cxx1</code> to hold it to avoid repeating:</p>
<div class="codeParentDiv" style="height:5em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const cxx1 = (c2.cx * ly - c2.cy * lx) - (fp.x[i] * ly - fp.y[i] * lx);</span></code></pre>
    </div></div>
    <p>Group the like terms and simplify it:</p>
<div class="codeParentDiv" style="height:5em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;</span></code></pre>
    </div></div>
    <p>Replace <code>cx - x1</code> with <code>cxx1</code> in the code:</p>
<div class="codeParentDiv" style="height:23em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
      const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;
      const relVx = c2.vx * ly - c2.vy * lx;
      if(((cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)) && cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)){
        const px = ((fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx) / (lx * lx + ly * ly);
        const py = (-(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly)  / (lx * lx + ly * ly);
        const dx = c2.cx-px;
        const dy = c2.cy-py;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Next, we may take away <code>/(lx * lx + ly * ly)</code> at <code>px</code> and <code>py</code>:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const px = (fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx;
const py = -(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly;</span></code></pre>
    </div></div>
    <p>then <code>dx</code> and <code>dy</code> becomes the following:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx = (c2.cx * (lx * lx + ly * ly) - px) / (lx * lx + ly * ly);
const dy = (c2.cy * (lx * lx + ly * ly) - py) / (lx * lx + ly * ly);</span></code></pre>
    </div></div>
    <p>Replace the formulae of <code>px</code>, <code>py</code>, <code>dx</code> and <code>dy</code> in the code:</p>
<div class="codeParentDiv" style="height:23em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
      const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;
      const relVx = c2.vx * ly - c2.vy * lx;
      if((cxx1 > 0 && cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly) && relVx < 0) || (0 > cxx1 &&  c2.r * c2.r * (lx * lx + ly * ly) >= cxx1 * cxx1 && relVx > 0)){
        const px = (fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx;
        const py = -(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly;
        const dx = (c2.cx * (lx * lx + ly * ly) - px) / (lx * lx + ly * ly);
        const dy = (c2.cy * (lx * lx + ly * ly) - py) / (lx * lx + ly * ly);
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Next, we would take away the <code>/(lx * lx + ly * ly)</code> at <code>dx</code> and <code>dy</code>:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx = c2.cx * (lx * lx + ly * ly) - px;
const dy = c2.cy * (lx * lx + ly * ly) - py;</span></code></pre>
    </div></div>
    <p>Then <code>vxFactor</code> becomes:</p>
<div class="codeParentDiv" style="height:5em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const vxFactor = (c2.vx * dx + c2.vy * dy) / (lx * lx + ly * ly);</span></code></pre>
    </div></div>
    <p>and the formulae of <code>c2.vx</code> and <code>c2.vy</code> becomes:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">c2.vx -= 2 * dx / (lx * lx + ly * ly) * vxFactor / (dx / (lx * lx + ly * ly) * dx / (lx * lx + ly * ly) + dy / (lx * lx + ly * ly) * dy / (lx * lx + ly * ly));
c2.vy -= 2 * dy / (lx * lx + ly * ly) * vxFactor / (dx / (lx * lx + ly * ly) * dx / (lx * lx + ly * ly) + dy / (lx * lx + ly * ly) * dy / (lx * lx + ly * ly));</span></code></pre>
    </div></div>
    <p>Then we would also take away the <code>/ (lx * lx + ly * ly)</code> at <code>vxFactor</code>:</p>
<div class="codeParentDiv" style="height:5em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const vxFactor = c2.vx * dx + c2.vy * dy;</span></code></pre>
    </div></div>
    <p>now the formulae of <code>c2.vx</code> and <code>c2.vy</code> becomes:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">c2.vx -= 2 * dx / (lx * lx + ly * ly) * vxFactor / (lx * lx + ly * ly) / (dx / (lx * lx + ly * ly) * dx / (lx * lx + ly * ly) + dy / (lx * lx + ly * ly) * dy / (lx * lx + ly * ly));
c2.vy -= 2 * dy / (lx * lx + ly * ly) * vxFactor / (lx * lx + ly * ly) / (dx / (lx * lx + ly * ly) * dx / (lx * lx + ly * ly) + dy / (lx * lx + ly * ly) * dy / (lx * lx + ly * ly));</span></code></pre>
    </div></div>
    <p>At the formulae of <code>c2.vx</code> and <code>c2.vy</code>, we may see both the upper and lower part have 2 <code>/(lx * lx + ly * ly)</code>, so we can remove all <code>/(lx * lx + ly * ly)</code> at the formulae safely, the code becomes:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);</span></code></pre>
    </div></div>
    <p>Then we may find the formulae of <code>c2.vx</code> and <code>c2.vy</code> is unchanged:</p>
<div class="codeParentDiv" style="height:23em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
      const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;
      const relVx = c2.vx * ly - c2.vy * lx;
      if(((cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)) && cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)){
        const px = (fp.x[i] * ly - fp.y[i] * lx) * ly + (c2.cx * lx + c2.cy * ly) * lx;
        const py = -(fp.x[i] * ly - fp.y[i] * lx) * lx + (c2.cx * lx + c2.cy * ly) * ly;
        const dx = c2.cx * (lx * lx + ly * ly) - px;
        const dy = c2.cy * (lx * lx + ly * ly) - py;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Now we would eliminate <code>px</code> and <code>py</code> : put them into the formulae of <code>dx</code> and <code>dy</code> directly:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx = c2.cx * (lx * lx + ly * ly) - (fp.x[i] * ly - fp.y[i] * lx) * ly - (c2.cx * lx + c2.cy * ly) * lx;
const dy = c2.cy * (lx * lx + ly * ly) + (fp.x[i] * ly - fp.y[i] * lx) * lx - (c2.cx * lx + c2.cy * ly) * ly;</span></code></pre>
    </div></div>
    <p>Expand the formulae of <code>dx</code> and <code>dy</code>:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx = c2.cx * lx * lx + c2.cx * ly * ly - fp.x[i] * ly * ly + fp.y[i] * lx * ly - c2.cx * lx * lx - c2.cy * lx * ly;
const dy = c2.cy * lx * lx + c2.cy * ly * ly + fp.x[i] * lx * ly - fp.y[i] * lx * lx - c2.cx * lx * ly - c2.cy * ly * ly;</span></code></pre>
    </div></div>
    <p>At the formula of <code>dx</code>, we may see <code>c2.cx * lx * lx</code> can be cancelled, also at the formula of <code>dy</code>, <code>c2.cy * ly * ly</code> can be cancelled, so the formulae now becomes:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx = c2.cx * ly * ly - fp.x[i] * ly * ly + fp.y[i] * lx * ly - c2.cy * lx * ly;
const dy = c2.cy * lx * lx + fp.x[i] * lx * ly - fp.y[i] * lx * lx - c2.cx * lx * ly;</span></code></pre>
    </div></div>
    <p>Now we may see the terms at <code>dx</code> have common factor <code>ly</code>, also the terms at <code>dy</code> have common factor <code>lx</code>, we can take the common factor out:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx = (c2.cx * ly - fp.x[i] * ly + fp.y[i] * lx - c2.cy * lx) * ly;
const dy = (c2.cy * lx + fp.x[i] * ly - fp.y[i] * lx - c2.cx * ly) * lx;</span></code></pre>
    </div></div>
    <p>Then group the like terms at <code>dx</code> and <code>dy</code>:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx = ((c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx) * ly;
const dy = ((c2.cy - fp.y[i]) * lx - (c2.cx - fp.x[i]) * ly) * lx;</span></code></pre>
    </div></div>
    <p>Rewrite the formula of <code>dy</code>:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx = ((c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx) * ly;
const dy = -((c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx) * lx;</span></code></pre>
    </div></div>
    <p>We may find that <code>dx</code> and <code>dy</code> actually consists of <code>cxx1</code>! So put <code>cxx1</code> into the formulae:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const dx = cxx1 * ly;
const dy = -cxx1 * lx;</span></code></pre>
    </div></div>
<p>Update the formulae of <code>dx</code> and <code>dy</code> in the code:</p>
<div class="codeParentDiv" style="height:21em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
      const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;
      const relVx = c2.vx * ly - c2.vy * lx;
      if(((cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)) && cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)){
        const dx = cxx1 * ly;
        const dy = -cxx1 * lx;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
        c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Next, we would eliminate <code>dx</code> and <code>dy</code> by putting <code>cxx1 * ly</code> and <code>-cxx1 * lx</code> into <code>vxFactor</code>, <code>c2.vx</code> and <code>c2.vy</code> directly:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const vxFactor = c2.vx * cxx1 * ly + c2.vy * -cxx1 * lx;
c2.vx -= 2 * cxx1 * ly * vxFactor / (cxx1 * ly * cxx1 * ly + -cxx1 * lx * -cxx1 * lx);
c2.vy -= 2 * -cxx1 * lx * vxFactor / (cxx1 * ly * cxx1 * ly + -cxx1 * lx * -cxx1 * lx);</span></code></pre>
    </div></div>
    <p>We may find that <code>vxFactor</code> has common factor <code>cxx1</code>:</p>
<div class="codeParentDiv" style="height:5em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const vxFactor = (c2.vx * ly - c2.vy * lx) * cxx1;</span></code></pre>
</div></div>
    <p>To simplify <code>vxFactor</code>, we may take away <code>cxx1</code> and put it to the formulae of <code>c2.vx</code> and <code>c2.vy</code>:</p>
<div class="codeParentDiv" style="height:8em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const vxFactor = c2.vx * ly - c2.vy * lx;
c2.vx -= 2 * cxx1 * ly * vxFactor * cxx1 / (cxx1 * ly * cxx1 * ly + -cxx1 * lx * -cxx1 * lx);
c2.vy -= 2 * -cxx1 * lx * vxFactor *cxx1 / (cxx1 * ly * cxx1 * ly + -cxx1 * lx * -cxx1 * lx);</span></code></pre>
</div></div>
    <p>Wait... we found that now <code>vxFactor</code> becomes <code>relVx</code> before! So we may replace <code>vxFactor</code> with <code>relVx</code> and rewrite the formulae of <code>c2.vx</code> and <code>c2.vy</code> as:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">c2.vx -= 2 * cxx1 * ly * relVx * cxx1 / (cxx1 * ly * cxx1 * ly + -cxx1 * lx * -cxx1 * lx);
c2.vy -= 2 * -cxx1 * lx * relVx *cxx1 / (cxx1 * ly * cxx1 * ly + -cxx1 * lx * -cxx1 * lx);</span></code></pre>
</div></div>
    <p>Also we found both upper and lower part of the formulae has 2 <code>cxx1</code>, so we may remove all cxx1 at the formulae directly:</p>
<div class="codeParentDiv" style="height:6em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">c2.vx -= 2 * ly * relVx / (ly * ly + lx * lx);
c2.vy += 2 * lx * relVx / (ly * ly + lx * lx);</span></code></pre>
</div></div>
    <p>The code becomes:</p>
<div class="codeParentDiv" style="height:18em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
      const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;
      const relVx = c2.vx * ly - c2.vy * lx;
      if(((cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)) && cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)){
        c2.vx -= 2 * ly * relVx / (ly * ly + lx * lx);
        c2.vy += 2 * lx * relVx / (ly * ly + lx * lx);
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Moreever, we can separate the collision detection and response part. <code>(cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)</code> is checking if the circle is approaching the line segments, but sometimes we way just want to check if a static circle overlaps with the line segment, which is independent to the velocity.</p>
    <p>Morever, you may assume that <code>cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)</code> comes from the condition that <b>the distance between c1 and x1 must equal to or smaller than c2.r if collision occurs</b> : <code>Math.abs(cx - x1) <= c2.r</code>, then it becomes <code>(cx - x1) * (cx - x1) <= c2.r *c2.r</code> and finally simplifies it as <code>cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)</code>.</p>
    <p>So we can separate the condition:</p>

<div class="codeParentDiv" style="height:19em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">.
.
.
if(cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)){ //check if the circle touches the line segment
  const relVx = c2.vx * ly - c2.vy * lx;
  if((cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)){ //check if the circle is approaching to the line segment
    .
    .
    .
  }
}
.
.
.</span></code></pre>
    </div></div>

    <p>Finally the collision code becomes:</p>
<div class="codeParentDiv" style="height:19em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[i+1] - fp.x[i];
  const ly = fp.y[i+1] - fp.y[i];
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
      const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;
      if(cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)){ //check if the circle touches the line segment
        const relVx = c2.vx * ly - c2.vy * lx;
        if((cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)){ //check if the circle is approaching to the line segment
          c2.vx -= 2 * ly * relVx / (ly * ly + lx * lx);
          c2.vy += 2 * lx * relVx / (ly * ly + lx * lx);
        }
      }
    }
  }
}</span></code></pre>
    </div></div>
    <p>Is the code correct? Now replace the raw line segment and circle collision code with the new code above:</p>
<div class="codeParentDiv" style="height:169em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fp = {
    x:[-90,-15],
    y:[ 30, 75]
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  const intervalId=setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed point and circle check collision
    for(let i=0;i < fp.x.length;i++){
      for(const c2 of circleArray){
        const dx=c2.cx-fp.x[i];
        const dy=c2.cy-fp.y[i];
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( dx * dx + dy * dy <= c2.r * c2.r && vxFactor < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }
    //line segment and circle collision
    for(let i=0;i < fp.x.length-1;i++){
      const lx = fp.x[i+1] - fp.x[i];
      const ly = fp.y[i+1] - fp.y[i];
      for(const c2 of circleArray){
        if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
          const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;
          if(cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)){ //check if the circle touches the line segment
            const relVx = c2.vx * ly - c2.vy * lx;
            if((cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)){ //check if the circle is approaching to the line segment
              c2.vx -= 2 * ly * relVx / (ly * ly + lx * lx);
              c2.vy += 2 * lx * relVx / (ly * ly + lx * lx);
            }
          }
        }
      }
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && vxFactor < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && vxFactor > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point
    for(let i=0;i < fp.x.length;i++){
      ctx.beginPath();
      ctx.fillStyle=ctx.strokeStyle="black";
      ctx.fillText(fp.x[i].toFixed(1)+","+fp.y[i].toFixed(1),canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.fillStyle=ctx.strokeStyle="gray";
      ctx.arc(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i],2,0,2*Math.PI);
      ctx.fill();
    }
    //draw line segment
    for(let i=0;i < fp.x.length-1;i++){
      ctx.beginPath();
      ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.lineTo(canvas.width/2+fp.x[i+1],canvas.height/2-fp.y[i+1]);
      ctx.stroke();
    }

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>The circle should rebound the same way as before:</p>
    <iframe id="iframe-chapter_8_6_1-1" class="center" src="chapter_8_6_1.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_6_1-1').src+='';">Reload</button>
    <p>But now the number of lines are fewer!</p>
    <p>Great! After implementing line segment and circle collision, we can also implement multiple line segments and circle collision as well as static polygon and circle collision!</p>
    <hr class="hr1"/>
    <h2 id="section_7">8.7 Multiple (Connected) line segments and circle collision</h2>
    <p>Now it is great that our physics engine support line segment and circle collision. However, what if a line segment connects with other line segments? How can we handle the collisions between that 2 line segments? eg:</p>
    <iframe class="center" src="chapter_8_7_1.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <p>The answer is simple: just add the new point at the <code>x</code> and <code>y</code>!</p>
    <p>The canvas above added a new point <b>(-60,-30)</b>, now there are 2 line segments <b>(-60,-30) , (90,30)</b> and <b>(90,30) , (-15,75)</b>. </p>
    <p>The general formula of checking line segments collision is: <b>checking line segment collision between (x<sub>0</sub>,y<sub>0</sub> --- x<sub>1</sub>,y<sub>1</sub>) , (x<sub>1</sub>,y<sub>1</sub> --- x<sub>2</sub>,y<sub>2</sub>) , ... (x<sub>n-2</sub>,y<sub>n-2</sub> --- x<sub>n-1</sub>,y<sub>n-1</sub>)</b>.</p>
    <p>Our loop at line segment collision code is already doing this! So we just need to add the point <b>(-60,-30)</b> at <code>fp.x</code> and <code>fp.y</code> as the following:</p>
<div class="codeParentDiv" style="height:168em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fp = {
    x:[-60,-90,-15],
    y:[-30, 30, 75]
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  const intervalId=setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed point and circle check collision
    for(let i=0;i < fp.x.length;i++){
      for(const c2 of circleArray){
        const dx=c2.cx-fp.x[i];
        const dy=c2.cy-fp.y[i];
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( dx * dx + dy * dy <= c2.r * c2.r && vxFactor < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }
    //line segment and circle collision
    for(let i=0;i < fp.x.length-1;i++){
      const lx = fp.x[i+1] - fp.x[i];
      const ly = fp.y[i+1] - fp.y[i];
      for(const c2 of circleArray){
        if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[i+1]) * lx < -(c2.cy - fp.y[i+1]) * ly){
          const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;
          if(cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)){ //check if the circle touches the line segment
            const relVx = c2.vx * ly - c2.vy * lx;
            if((cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)){ //check if the circle is approaching to the line segment
              c2.vx -= 2 * ly * relVx / (ly * ly + lx * lx);
              c2.vy += 2 * lx * relVx / (ly * ly + lx * lx);
            }
          }
        }
      }
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && vxFactor < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && vxFactor > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point
    for(let i=0;i < fp.x.length;i++){
      ctx.beginPath();
      ctx.fillStyle=ctx.strokeStyle="black";
      ctx.fillText(fp.x[i].toFixed(1)+","+fp.y[i].toFixed(1),canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.fillStyle=ctx.strokeStyle="gray";
      ctx.arc(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i],2,0,2*Math.PI);
      ctx.fill();
    }
    //draw line segment
    for(let i=0;i < fp.x.length-1;i++){
      ctx.beginPath();
      ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.lineTo(canvas.width/2+fp.x[i+1],canvas.height/2-fp.y[i+1]);
      ctx.stroke();
    }

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>Now the circle should collide with a line segment and then collide with another line segment as the following:</p>
    <iframe id="iframe-chapter_8_7_2-1" class="center" src="chapter_8_7_2.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_7_2-1').src+='';">Reload</button>
    <p>Great! Polygons can be view as multiple line segments, so in next section we would modify the line segment collision code so that it supports collision between a fixed polygon and circles!</p>
    <hr class="hr1"/>
    <h2 id="section_8">8.8 Fixed polygon and circle collision</h2>
    <p>Now it is great that our physics engine support line segment and circle collision. <b>Polygons can be view as multiple line segments which the start and end points are connected</b>:</p>
    <iframe class="center" src="chapter_8_8_1.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <p>However, how can we write codes to connect the start and end point?</p>
    <p>Recall that the general formula of checking line segments collision is:</p>
    <p>(x<sub>0</sub>,y<sub>0</sub> --- x<sub>1</sub>,y<sub>1</sub>) , (x<sub>1</sub>,y<sub>1</sub> --- x<sub>2</sub>,y<sub>2</sub>) , ... (x<sub>i</sub>,y<sub>i</sub> --- x<sub>i+1</sub>,y<sub>i+1</sub>) ... , ... (x<sub>n-2</sub>,y<sub>n-2</sub> --- x<sub>n-1</sub>,y<sub>n-1</sub>)</b></p>
    <p>When the line segments are closed, it means <b>the start and end points are connected:</b></p>
    <p>(x<sub>0</sub>,y<sub>0</sub> --- x<sub>1</sub>,y<sub>1</sub>) , (x<sub>1</sub>,y<sub>1</sub> --- x<sub>2</sub>,y<sub>2</sub>) , ... (x<sub>i</sub>,y<sub>i</sub> --- x<sub>i+1</sub>,y<sub>i+1</sub>) ... , ... (x<sub>n-2</sub>,y<sub>n-2</sub> --- x<sub>n-1</sub>,y<sub>n-1</sub>) , <b>(x<sub>n-1</sub>,y<sub>n-1</sub> --- x<sub>0</sub>,y<sub>0</sub>)</b></p>
    <p>However, currently the <code>i</code> in for loop are just increasing:</p>
    <p>(x<sub>0</sub>,y<sub>0</sub> --- x<sub>1</sub>,y<sub>1</sub>) , (x<sub>1</sub>,y<sub>1</sub> --- x<sub>2</sub>,y<sub>2</sub>) , ... (x<sub>i</sub>,y<sub>i</sub> --- x<sub>i+1</sub>,y<sub>i+1</sub>) ... , ... (x<sub>n-2</sub>,y<sub>n-2</sub> --- x<sub>n-1</sub>,y<sub>n-1</sub>) , <b>(x<sub>n-1</sub>,y<sub>n-1</sub> --- x<sub>n</sub>,y<sub>n</sub>) (already out of the bound of the arrays!)</b></p>
    <p>While <code>i</code> would reach n-1 (last point) at last <code>i+1</code> would <b>reach n</b>, which <b>array index starts from 0 to n-1 and n is already exceeds the max index of the array</b>! Now we need to let the i to go back to 0 after it reaches n-1 (last point)... How can we 'force' <b>i</b> to go back?</p>
    <p>The answer is :<b>add</b> <code>(i+1) % n</code> <b>into the code</b>! <code>(i+1) % n</code> returns the remainder when <code>i+1</code> is divided by n, eg: 4 % 5 equals to 4 and 5 % 5 equals to 0. At our code, n actually means <code>fp.x.length</code> and <code>fp.y.length</code>, so our code would look like:</p>
<div class="codeParentDiv" style="height:27em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i=0;i < fp.x.length-1;i++){
  const lx = fp.x[(i+1)%fp.x.length] - fp.x[i];
  const ly = fp.y[(i+1)%fp.x.length] - fp.y[i];
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[(i+1)%fp.x.length]) * lx < -(c2.cy - fp.y[(i+1)%fp.x.length]) * ly){
      .
      .
      .
      }
    }
  }
}
.
.
.
for(let i=0;i < fp.x.length-1;i++){
  ctx.beginPath();
  ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
  ctx.lineTo(canvas.width/2+fp.x[(i+1)%fp.x.length],canvas.height/2-fp.y[(i+1)%fp.x.length]);
  ctx.stroke();
}
.
.
.</span></code></pre>
    </div></div>
    <p>However, <code>(i+1)%fp.x.length</code> is a bit long, so we would create a new variable <code>j</code> in the loop like the following:</p>
<div class="codeParentDiv" style="height:24em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i = 0 , j = 1 ; i < fp.x.length-1 ; i++ , j = (i+1) % fp.x.length){
  const lx = fp.x[j] - fp.x[i];
  const ly = fp.y[j] - fp.y[i];
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[j]) * lx < -(c2.cy - fp.y[j]) * ly){
      .
      .
      .
      }
    }
  }
}
.
.
.
for(let i = 0 , j = 1 ; i < fp.x.length-1 ; i++ , j = (i+1) % fp.x.length){
  ctx.beginPath();
  ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
  ctx.lineTo(canvas.width/2+fp.x[j],canvas.height/2-fp.y[j]);
  ctx.stroke();
}</span></code></pre>
    </div></div>
    <p>Also currently the loops run only when <code>i < fp.x.length-1</code>, but we need <code>i < fp.x.length</code> so that the last step ends at n,0:</p>
<div class="codeParentDiv" style="height:24em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">//line segment and circle collision
for(let i = 0 , j = 1 ; i < fp.x.length ; i++ , j = (i+1) % fp.x.length){
  const lx = fp.x[j] - fp.x[i];
  const ly = fp.y[j] - fp.y[i];
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[j]) * lx < -(c2.cy - fp.y[j]) * ly){
      .
      .
      .
      }
    }
  }
}
.
.
.
for(let i = 0 , j = 1 ; i < fp.x.length ; i++ , j = (i+1) % fp.x.length){
  ctx.beginPath();
  ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
  ctx.lineTo(canvas.width/2+fp.x[j],canvas.height/2-fp.y[j]);
  ctx.stroke();
}</span></code></pre>
    </div></div>
    <p>However, we also want to keep the ability of handling opened line segments, so we would add a new boolean field at <code>fp</code> : <code>isClosed</code>, which lets <code>fp</code> decides if it is closed freely, also <code>isClosed</code> uses to decides where the loop ends at:</p>
<div class="codeParentDiv" style="height:36em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">.
.
.
const fp = {
  x:[-60,-90,-15],
  y:[-30, 30, 75],
  isClosed:true
};
.
.
.
//line segment and circle collision
for(let i = 0 , j = 1 ; i < fp.isClosed ? i < fp.x.length : i < fp.x.length - 1 ; i++ , j = (i+1) % fp.x.length){
  const lx = fp.x[j] - fp.x[i];
  const ly = fp.y[j] - fp.y[i];
  for(const c2 of circleArray){
    if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[j]) * lx < -(c2.cy - fp.y[j]) * ly){
      .
      .
      .
      }
    }
  }
}
.
.
.
//draw line segment
for(let i = 0 , j = 1 ; i < fp.isClosed ? i < fp.x.length : i < fp.x.length - 1 ; i++ , j = (i+1) % fp.x.length){
  ctx.beginPath();
  ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
  ctx.lineTo(canvas.width/2+fp.x[j],canvas.height/2-fp.y[j]);
  ctx.stroke();
}</span></code></pre>
    </div></div>
    <p>So add the changes to the canvas:</p>
<div class="codeParentDiv" style="height:169em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fp = {
    x:[-60,-90,-15],
    y:[-30, 30, 75],
    isClosed:true
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  const intervalId=setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //fixed point and circle check collision
    for(let i=0;i < fp.x.length;i++){
      for(const c2 of circleArray){
        const dx=c2.cx-fp.x[i];
        const dy=c2.cy-fp.y[i];
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( dx * dx + dy * dy <= c2.r * c2.r && vxFactor < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }
    //line segment and circle collision
    for(let i = 0 , j = 1 ; fp.isClosed ? i < fp.x.length : i < fp.x.length - 1 ; i++ , j = (i+1) % fp.x.length){
      const lx = fp.x[j] - fp.x[i];
      const ly = fp.y[j] - fp.y[i];
      for(const c2 of circleArray){
        if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[j]) * lx < -(c2.cy - fp.y[j]) * ly){
          const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;
          if(cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)){ //check if the circle touches the line segment
          const relVx = c2.vx * ly - c2.vy * lx;
            if((cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)){ //check if the circle is approaching to the line segmen
              c2.vx -= 2 * ly * relVx / (ly * ly + lx * lx);
              c2.vy += 2 * lx * relVx / (ly * ly + lx * lx);
            }
          }
        }
      }
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && vxFactor < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && vxFactor > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point
    for(let i=0;i < fp.x.length;i++){
      ctx.beginPath();
      ctx.fillStyle=ctx.strokeStyle="black";
      ctx.fillText(fp.x[i].toFixed(1)+","+fp.y[i].toFixed(1),canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.fillStyle=ctx.strokeStyle="gray";
      ctx.arc(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i],2,0,2*Math.PI);
      ctx.fill();
    }
    //draw line segment
    for(let i = 0 , j = 1 ; fp.isClosed ? i < fp.x.length : i < fp.x.length - 1 ; i++ , j = (i+1) % fp.x.length){
      ctx.beginPath();
      ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
      ctx.lineTo(canvas.width/2+fp.x[j],canvas.height/2-fp.y[j]);
      ctx.stroke();
    }

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>Now the circle should collide with a line segment and then collide with another line segment as the following:</p>
    <iframe id="iframe-chapter_8_8_2-1" class="center" src="chapter_8_8_2.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_8_2-1').src+='';">Reload</button>
    <p>Now the canvas support both solely line segments and a fixed polygon collision! But it contains one fixed polygon only, so in next section we would add supporting multiple fixed polygons!</p>
    <hr class="hr1"/>
    <h2 id="section_9">8.9 Multiple fixed polygons and circle collision</h2>
    <p>Now the canvas support both solely line segments and a fixed polygon collision! But it contains one fixed polygon (<code>fp</code>) only, so we would add codes to support multiple fixed polygons and line segments:</p>
    <iframe id="iframe-chapter_8_9_1-1" class="center" src="chapter_8_9_1.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <p>To add multiple fixed polygons, new we remove the original <code>fp</code>, create an array :<code>fixedPolygonArray</code>, to store the original fixed polygon, also add a new line segment (<code>isClosed is false</code>) into it as the following:</p>
<div class="codeParentDiv" style="height:15em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">const fixedPolygonArray = [
  {
    x:[-60,-90,-15],
    y:[-30, 30, 75],
    isClosed:true
  },
  {
    x:[ 60 ,150,75],
    y:[ -75,-15, 75],
    isClosed:false
  }
];</span></code></pre>
    </div></div>
    <p>Also we would enclose the original fixed point and line segment collision and drawing codes with the for loop:</p>
<div class="codeParentDiv" style="height:41em"><div class="hljs readborder" style="position:absolute;">
<pre><code><span class="hl">.
.
.
//fixed point and line segment collision
for(const fp of fixedPolygonArray){
  //fixed point and circle check collision
  for(let i=0;i < fp.x.length;i++){
    .
    .
    .
  }
  //line segment and circle collision
  for(let i = 0 , j = 1 ; fp.isClosed ? i < fp.x.length : i < fp.x.length - 1 ; i++ , j = (i+1) % fp.x.length){
    .
    .
    .
  }
}
.
.
.
//draw fixed point and line segment
for(const fp of fixedPolygonArray){
  //draw fixed point
  for(let i=0;i < fp.x.length;i++){
    .
    .
    .
  }
  //draw line segment
  for(let i = 0 , j = 1 ; fp.isClosed ? i < fp.x.length : i < fp.x.length - 1 ; i++ , j = (i+1) % fp.x.length){
    .
    .
    .
  }
}
.
.
.</span></code></pre>
    </div></div>
    <p>Modify the code, add the for loops, enclose the original collision codes and drawing codes as the following:</p>
<div class="codeParentDiv" style="height:181em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {    
      cx:90,
      cy:-15,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-90,
      vy:30
    }
  ];

  const fixedCircleArray = [
  ];

  const fixedPolygonArray = [
    {
      x:[-60,-90,-15],
      y:[-30, 30, 75],
      isClosed:true
    },
    {
      x:[ 60 ,150,75],
      y:[ -75,-15, 75],
      isClosed:false
    }
  ];

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  const intervalId=setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    for(const fp of fixedPolygonArray){
      //fixed point and circle check collision
      for(let i=0;i < fp.x.length;i++){
        for(const c2 of circleArray){
          const dx=c2.cx-fp.x[i];
          const dy=c2.cy-fp.y[i];
          const vxFactor = c2.vx * dx + c2.vy * dy;
          if( dx * dx + dy * dy <= c2.r * c2.r && vxFactor < 0){ //apply collision only if 2 circles touch and the direction of speed is correct
            c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
            c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
          }
        }
      }
      //line segment and circle collision
      for(let i = 0 , j = 1 ; fp.isClosed ? i < fp.x.length : i < fp.x.length - 1 ; i++ , j = (i+1) % fp.x.length){
        const lx = fp.x[j] - fp.x[i];
        const ly = fp.y[j] - fp.y[i];
        for(const c2 of circleArray){
          if((c2.cx - fp.x[i]) * lx > -(c2.cy - fp.y[i]) * ly && (c2.cx - fp.x[j]) * lx < -(c2.cy - fp.y[j]) * ly){
            const cxx1 = (c2.cx - fp.x[i]) * ly - (c2.cy - fp.y[i]) * lx;
            if(cxx1 * cxx1 <= c2.r * c2.r * (lx * lx + ly * ly)){ //check if the circle touches the line segment
            const relVx = c2.vx * ly - c2.vy * lx;
              if((cxx1 > 0 && relVx < 0) || (0 > cxx1 && relVx > 0)){ //check if the circle is approaching to the line segmen
                c2.vx -= 2 * ly * relVx / (ly * ly + lx * lx);
                c2.vy += 2 * lx * relVx / (ly * ly + lx * lx);
              }
            }
          }
        }
      }
    }

    //fixed circle and circle check collision
    for(const fc of fixedCircleArray){
      for(const c2 of circleArray){
        const dx=c2.cx-fc.cx;
        const dy=c2.cy-fc.cy;
        const vxFactor = c2.vx * dx + c2.vy * dy;
        if( (dx * dx + dy * dy >= fc.r * fc.r && dx * dx + dy * dy <= (fc.r + c2.r)*(fc.r + c2.r) && vxFactor < 0) || (dx * dx + dy * dy <= fc.r * fc.r && dx * dx + dy * dy >= (fc.r - c2.r)*(fc.r - c2.r) && vxFactor > 0)){ //apply collision only if 2 circles touch and the direction of speed is correct
          c2.vx -= 2 * dx * vxFactor / (dx * dx + dy * dy);
          c2.vy -= 2 * dy * vxFactor / (dx * dx + dy * dy);
        }
      }
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw fixed point and line segment
    for(const fp of fixedPolygonArray){
      //draw fixed point
      for(let i=0;i < fp.x.length;i++){
        ctx.beginPath();
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.fillText(fp.x[i].toFixed(1)+","+fp.y[i].toFixed(1),canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.arc(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i],2,0,2*Math.PI);
        ctx.fill();
      }
      //draw line segment
      for(let i = 0 , j = 1 ; fp.isClosed ? i < fp.x.length : i < fp.x.length - 1 ; i++ , j = (i+1) % fp.x.length){
        ctx.beginPath();
        ctx.moveTo(canvas.width/2+fp.x[i],canvas.height/2-fp.y[i]);
        ctx.lineTo(canvas.width/2+fp.x[j],canvas.height/2-fp.y[j]);
        ctx.stroke();
      }
    }

    //draw fixed circle
    for(let i=0;i < fixedCircleArray.length;i++){
        const fc=fixedCircleArray[i];
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,fc.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText("FC"+i,canvas.width/2+fc.cx,canvas.height/2-fc.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+fc.cx,canvas.height/2-fc.cy,2,0,2*Math.PI);
        ctx.fill();
    }

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>Now the canvas should show a circle rebounds between a triangle and a line segment as the following:</p>
    <iframe id="iframe-chapter_8_9_2-1" class="center" src="chapter_8_9_2.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_8_9_2-1').src+='';">Reload</button>
    <p>Now the circle can collide width multiple fixed polygons and different lengths of line segments into the canvas!</p>
        </div></td>
      </tr>
    </table>
  </body>
  <script src="highlight/highlight.min.js"></script>
  <script>
  document.querySelectorAll('.hl').forEach(el => {
    hljs.highlightElement(el);
  });
  </script>
</html>
