<!doctype html>
<html>
  <head>
    <meta charset="UTF-8"/>
  </head>
  <link rel="stylesheet" href="highlight/styles/github-dark.min.css">
  <style>
    code{
      background-color:#D3D3D3;
    }
    .center{
      margin-left:auto;
      margin-right:auto;
      display:block;
    }
    .hr1{
        height:0.5em;background-color:lightgrey;
    }
    .dimdiv{
      position:absolute;
      top:0;
      width:100%;
      pointer-events: none;
    }
    .dimcode{
      background-color:black;
      opacity:0.625;
      width:100%;
      display:block;
    }
    .showcode{
      width:100%;
      opacity:0;
      display:block;
    }
    .readborder{
      border:0.25em solid black;
    }
    .copyborder{
      border:0.5em dashed gray;
    }
    .codeParentDiv{
      position:relative;
      overflow-x:scroll;
    }
  </style>
  <body>
<table style="position:fixed;top:0%;left:0%;width:auto;height:100%;background-color:lightgrey">
      <tr>
        <td style="border: 1px solid black;">
          <span><b>Attention:</b>Repository : <a href="https://github.com/shuffleandko/circle-collision-without-vector">https://github.com/shuffleandko/circle-collision-without-vector</a>. The correctness of this tutorial is not guaranteed, the context may be updated without notifications, and the author is not responsible for any consequences that copy or run the codes in the tutorial, if any.</span>
          <hr/>
          <span><b>Go to chapter: </b></span>
          <select onChange="window.location.href=this.value">
            <option value="chapter_1.html">Chapter 1 : Introduction</option>
            <option value="chapter_2.html">Chapter 2 : Draw something on browsers using canvas element</option>
            <option value="chapter_3.html">Chapter 3 : Move the circle</option>
            <option value="chapter_4.html">Chapter 4 : Circle-circle collision detection</option>
            <option value="chapter_5.html">Chapter 5 : Circle-circle collision response</option>
            <option value="chapter_6.html" selected disabled>Chapter 6 : Use array to avoid repeating codes</option>
            <option value="chapter_7.html">Chapter 7 : Circles and fixed circles collision</option>
            <option value="chapter_8.html">Chapter 8 : Circles and fixed points, lines and fixed polygons collision</option>
            <option value="chapter_9.html">Chapter 9 : Test all objects working together and remove debug drawings</option>
          </select>
          <hr/>
          <button onclick="window.location.href='#top'">▲ Go back to top ▲</button>&nbsp<span><b>Move to section</b>:
            <select onChange="window.location.href=this.value">
              <option value="#section_1">6.1 Using array to avoid repeating codes at updating positions and drawing circles</option>
              <option value="#section_2">6.2 Move collision codes into a for loop : support multiple circles</option>
            </select>
          </span>
        </td>
      </tr>
      <tr style="width:width:100%;height:100%;">
        <td style="width:100%;height:100%;"><div style="background-color:white;overflow-x:auto;overflow-y:scroll;width:width:100%;height:100%;padding-left:0.5em;">
          <div id="top"></div> 
    <h1 style="text-align:center;">Chapter 6 : Use array to avoid repeating codes</h1>
    <hr class="hr1"/>
    <h2 id="section_1">6.1 Using array to avoid repeating codes at updating positions and drawing circles</h2>
    <p>At former chapter, we implemented the circle collision code, recall the code at former chapter:</p>
<div class="codeParentDiv" style="height:106em"><div class="hljs copyborder" style="position:absolute;">
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">const c1={
    cx:-45,
    cy:-75,
    r:50,
    m:Math.PI*50*50, //mass = area
    vx:15,
    vy:30
  };

  const c2={
    cx:135,
    cy:-90,
    r:30,
    m:Math.PI*30*30, //mass = area
    vx:-45,
    vy:60
  };

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  setInterval(function(){
    //circle collision
    c1.cx+=c1.vx*1/frameRate;
    c1.cy+=c1.vy*1/frameRate;
    c2.cx+=c2.vx*1/frameRate;
    c2.cy+=c2.vy*1/frameRate;

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    const dx=c2.cx-c1.cx;
    const dy=c2.cy-c1.cy;
    if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
      const rel_c2vx = c2.vx - c1.vx;
      const rel_c2vy = c2.vy - c1.vy;
      if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
        c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
        c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
        c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
        c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw circle
    ctx.beginPath();
    ctx.arc(canvas.width/2+c1.cx,canvas.height/2-c1.cy,c1.r,0,2*Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillText(c1.cx.toFixed(1)+","+c1.cy.toFixed(1),canvas.width/2+c1.cx,canvas.height/2-c1.cy+16);
    ctx.fillStyle=ctx.strokeStyle="blue";
    ctx.moveTo(canvas.width/2+c1.cx,canvas.height/2-c1.cy);
    ctx.lineTo(canvas.width/2+c1.cx+c1.vx,canvas.height/2-c1.cy-c1.vy);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(canvas.width/2+c1.cx+c1.vx,canvas.height/2-c1.cy-c1.vy,2,0,2*Math.PI);
    ctx.fill();
    ctx.fillText(c1.vx.toFixed(1)+","+c1.vy.toFixed(1),canvas.width/2+c1.cx+c1.vx,canvas.height/2-c1.cy-c1.vy-4);
    ctx.fillStyle=ctx.strokeStyle="gray";
    ctx.fillText("C1",canvas.width/2+c1.cx,canvas.height/2-c1.cy);
    ctx.fillStyle=ctx.strokeStyle="black";
    ctx.beginPath();
    ctx.arc(canvas.width/2+c1.cx,canvas.height/2-c1.cy,2,0,2*Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.arc(canvas.width/2+c2.cx,canvas.height/2-c2.cy,c2.r,0,2*Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillText(c2.cx.toFixed(1)+","+c2.cy.toFixed(1),canvas.width/2+c2.cx,canvas.height/2-c2.cy+16);
    ctx.fillStyle=ctx.strokeStyle="blue";
    ctx.moveTo(canvas.width/2+c2.cx,canvas.height/2-c2.cy);
    ctx.lineTo(canvas.width/2+c2.cx+c2.vx,canvas.height/2-c2.cy-c2.vy);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(canvas.width/2+c2.cx+c2.vx,canvas.height/2-c2.cy-c2.vy,2,0,2*Math.PI);
    ctx.fill();
    ctx.fillText(c2.vx.toFixed(1)+","+c2.vy.toFixed(1),canvas.width/2+c2.cx+c2.vx,canvas.height/2-c2.cy-c2.vy-4);
    ctx.fillStyle=ctx.strokeStyle="gray";
    ctx.fillText("C2",canvas.width/2+c2.cx,canvas.height/2-c2.cy);
    ctx.fillStyle=ctx.strokeStyle="black";
    ctx.beginPath();
    ctx.arc(canvas.width/2+c2.cx,canvas.height/2-c2.cy,2,0,2*Math.PI);
    ctx.fill();
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
    </div></div>
    <p>While the code looks working perfectly, it has a drawback: it needs to repeat some codes for 2 circles:</p>
<div class="codeParentDiv" style="height:57em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">.
    .
    .
    //circle position update
    c1.cx += c1.vx * 1 / frameRate;
    c1.cy += c1.vy * 1 / frameRate;
    c2.cx += c2.vx * 1 / frameRate;
    c2.cy += c2.vy * 1 / frameRate;
    .
    .
    .
    //draw circle
    ctx.beginPath();
    ctx.arc(canvas.width/2+c1.cx,canvas.height/2-c1.cy,c1.r,0,2*Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillText(c1.cx.toFixed(1)+","+c1.cy.toFixed(1),canvas.width/2+c1.cx,canvas.height/2-c1.cy+16);
    ctx.fillStyle=ctx.strokeStyle="blue";
    ctx.moveTo(canvas.width/2+c1.cx,canvas.height/2-c1.cy);
    ctx.lineTo(canvas.width/2+c1.cx+c1.vx,canvas.height/2-c1.cy-c1.vy);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(canvas.width/2+c1.cx+c1.vx,canvas.height/2-c1.cy-c1.vy,2,0,2*Math.PI);
    ctx.fill();
    ctx.fillText(c1.vx.toFixed(1)+","+c1.vy.toFixed(1),canvas.width/2+c1.cx+c1.vx,canvas.height/2-c1.cy-c1.vy-4);
    ctx.fillStyle=ctx.strokeStyle="gray";
    ctx.fillText("C1",canvas.width/2+c1.cx,canvas.height/2-c1.cy);
    ctx.fillStyle=ctx.strokeStyle="black";
    ctx.beginPath();
    ctx.arc(canvas.width/2+c1.cx,canvas.height/2-c1.cy,2,0,2*Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.arc(canvas.width/2+c2.cx,canvas.height/2-c2.cy,c2.r,0,2*Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillText(c2.cx.toFixed(1)+","+c2.cy.toFixed(1),canvas.width/2+c2.cx,canvas.height/2-c2.cy+16);
    ctx.fillStyle=ctx.strokeStyle="blue";
    ctx.moveTo(canvas.width/2+c2.cx,canvas.height/2-c2.cy);
    ctx.lineTo(canvas.width/2+c2.cx+c2.vx,canvas.height/2-c2.cy-c2.vy);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(canvas.width/2+c2.cx+c2.vx,canvas.height/2-c2.cy-c2.vy,2,0,2*Math.PI);
    ctx.fill();
    ctx.fillText(c2.vx.toFixed(1)+","+c2.vy.toFixed(1),canvas.width/2+c2.cx+c2.vx,canvas.height/2-c2.cy-c2.vy-4);
    ctx.fillStyle=ctx.strokeStyle="gray";
    ctx.fillText("C2",canvas.width/2+c2.cx,canvas.height/2-c2.cy);
    ctx.fillStyle=ctx.strokeStyle="black";
    ctx.beginPath();
    ctx.arc(canvas.width/2+c2.cx,canvas.height/2-c2.cy,2,0,2*Math.PI);
    ctx.fill();
    .
    .
    .
    .</span></code></pre>
    </div></div>
    <p>which <b>updating and drawing circle 1 (C1) and circle 2 (C2) are using almost the same code except the variable names</b>! If we want to add a new circle , eg: circle 3 (C3), we would need to repeat the code again!</p>
    <p>Repeating the codes not only makes the number of lines more, it is also a maintain nightmare because if one day we find problem at one part of the code, we may need to edit all repeated codes repeatly!</p>
    <p>So how can we avoid repeating codes at this case? The answer is : using <b>arrays</b>! Arrays allow us to store items in a single variable, also allows us to access each item with generic way : by the index.</p>
    <p>Now we would use a new array : <code>circleArray</code>, to store the 2 circles:</p>
<div class="codeParentDiv" style="height:5em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">const circleArray = [c1 , c2];</span></code></pre>
    </div></div>
    <p>To make the good use of arrays, we usually use it with <code>for(...)</code> in order to access different items with the same code. In our case, the position update codes would be moved into the for loop as the following:</p> 
<div class="codeParentDiv" style="height:15em"><div class="hljs readborder" style="position:absolute;">
    <pre><code><span class="hl">    .
    .
    .
    //circle position update
    for(const c of circleArray){
        c.cx += c1.vx * 1 / frameRate;
        c.cy += c1.vy * 1 / frameRate;
    }
    .
    .
    .</span></code></pre>
    </div></div>
    <p>Drawing codes would also be moved into the for loop, but we would use a counter <code>i</code> : <code>for(let i=0;i < circleArray.length;i++){</code> because we need to draw the index of each circle at the center: <code>ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);</code>.Also we would add <code>ctx.fillStyle=ctx.strokeStyle="black";</code> in order to reset the using color before drawing each circle, shown as the following:</p> 
<div class="codeParentDiv" style="height:34em"><div class="hljs readborder" style="position:absolute;">
    <pre><code><span class="hl">    .
    .
    .
    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
    .
    .
    .
    .</span></code></pre>
    </div></div>
    <p>Now we may replace the repeated update position and drawing codes with the for loop above:</p>
    <div class="codeParentDiv" style="height:94em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const c1={
    cx:-45,
    cy:-75,
    r:50,
    m:Math.PI*50*50, //mass = area
    vx:15,
    vy:30
  };

  const c2={
    cx:135,
    cy:-90,
    r:30,
    m:Math.PI*30*30, //mass = area
    vx:-45,
    vy:60
  };

  const circleArray = [c1 , c2];

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    const dx=c2.cx-c1.cx;
    const dy=c2.cy-c1.cy;
    if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
      const rel_c2vx = c2.vx - c1.vx;
      const rel_c2vy = c2.vy - c1.vy;
      if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
        c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
        c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
        c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
        c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>   
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>      
          <code class="showcode">&nbsp;</code>  
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>      
          <code class="showcode">&nbsp;</code>         
          <code class="showcode">&nbsp;</code>  
          <code class="showcode">&nbsp;</code>      
          <code class="showcode">&nbsp;</code>         
          <code class="showcode">&nbsp;</code>   
          <code class="showcode">&nbsp;</code>  
          <code class="showcode">&nbsp;</code>      
          <code class="showcode">&nbsp;</code>         
          <code class="showcode">&nbsp;</code>      
          <code class="showcode">&nbsp;</code>  
          <code class="showcode">&nbsp;</code>      
          <code class="showcode">&nbsp;</code>  
          <code class="showcode">&nbsp;</code>      
          <code class="showcode">&nbsp;</code>  
          <code class="showcode">&nbsp;</code>      
          <code class="showcode">&nbsp;</code>    
          <code class="showcode">&nbsp;</code>      
          <code class="showcode">&nbsp;</code>  
          <code class="showcode">&nbsp;</code>      
          <code class="showcode">&nbsp;</code>  
          <code class="showcode">&nbsp;</code> 
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
     </div></div>
    <p>The canvas should look almost the same as the version without array, except circle 1 (C1) becomes circle 0 (C0) (because array index starts from 0), also circle 2 (C2) becomes circle 1 (C1):</p>
    <iframe id="iframe-chapter_6_1_1-1" class="center" src="chapter_6_1_1.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_6_1_1-1').src+='';">Reload</button>
    <p>Now the collision part is not in the for loop because the mechanism of collision code is a bit different from updating position and drawing : it involves 2 circles each time. So we would modify the collision code at next section.</p>
    <h2 id="section_2">6.2 Move collision codes into a for loop : support multiple circles</h2>
    <p>Currently, the canvas has only 2 circles : <code>c1</code> and <code>c2</code>, the logic to check collision is simple: just checking <code>c1 vs c2</code> (Check if <code>c1</code> collides with <code>c2</code>, if so, apply collision on them). What if there are many other circles? eg:<code>c3</code>, <code>c4</code>, <code>c5</code>... How should we handle collision for multiple circles?</p>
    <p>The answer is : for each circle, check if it collides with other circles once! For example: <code>c1 vs c2</code>, <code>c1 vs c3</code>, <code>c1 vs c4</code> ... , <code>mc2 vs mc3</code>, ... <code>c4 vs c5</code>. It looks a bit difficult to understand, right? Let's list them using a table as the following:</p>
    <table border="1" style="margin-left:auto;margin-right:auto;text-align:center;">
      <tr>
        <td><s style="color:lightgray;">1 vs 1</s></td>
        <td>1 vs 2</td>
        <td>1 vs 3</td>
        <td>1 vs 4</td>
        <td>1 vs 5</td>
      </tr>
      <tr>
        <td><s style="color:lightgray;">2 vs 1</s></td>
        <td><s style="color:lightgray;">2 vs 2</s></td>
        <td>2 vs 3</td>
        <td>2 vs 4</td>
        <td>2 vs 5</td>
      </tr>
      <tr>
        <td><s style="color:lightgray;">3 vs 1</s></td>
        <td><s style="color:lightgray;">3 vs 2</s></td>
        <td><s style="color:lightgray;">3 vs 3</s></td>
        <td>3 vs 4</td>
        <td>3 vs 5</td>
      </tr>
      <tr>
        <td><s style="color:lightgray;">4 vs 1</s></td>
        <td><s style="color:lightgray;">4 vs 2</s></td>
        <td><s style="color:lightgray;">4 vs 3</s></td>
        <td><s style="color:lightgray;">4 vs 4</s></td>
        <td>4 vs 5</td>
      </tr>
      <tr>
        <td><s style="color:lightgray;">5 vs 1</s></td>
        <td><s style="color:lightgray;">5 vs 2</s></td>
        <td><s style="color:lightgray;">5 vs 3</s></td>
        <td><s style="color:lightgray;">5 vs 4</s></td>
        <td><s style="color:lightgray;">5 vs 5</s></td>
      </tr>
    </table>
    <p>From the table above, we may see the pattern : we don't need to check <code>1 vs 1</code> that collides with itself, also no need to check <code>2 vs 1</code> because collision has applied at the case <code>1 vs 2</code> before already. Now we would write a loop to print the <code>x vs y</code>:</p> 
<div class="codeParentDiv" style="height:8em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">for(let i = 0;i < 5;i++){
  for(let j = i;j < 5;j++){
    document.write(i+" vs "+j+" , ");
  }
}
</span></code></pre></div></div>
    <p>The output is : <b>0 vs 1 , 0 vs 2 , 0 vs 3 , 0 vs 4 , 1 vs 1 , 1 vs 2 , 1 vs 3 , 1 vs 4 , 2 vs 2 , 2 vs 3 , 2 vs 4 , 3 vs 3 , 3 vs 4 , 4 vs 4</b> , which is our desired pattern! Except the starting one is <code>0 vs 1</code> instead of <code>1 vs 2</code> because array index starts from 0. Assume <code>circleArray</code> has 5 circles, Then apply the loop to the collision code, but replacing <b>5</b> with the <b>length of the array</b>:</p>
<div class="codeParentDiv" style="height:28em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">    .
    .
    .
    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }
    .
    .
    .</span></code></pre></div></div>
    <p>To ensure we are accessing circles using array instead of variable <cod>c1</code> and <code>c2</code> before, we would delete these 2 variables and put the circle into the array directly:</p>
<div class="codeParentDiv" style="height:21em"><div class="hljs readborder" style="position:absolute;">
        <pre><code><span class="hl">  const circleArray = [
    {
      cx:-45,
      cy:-75,
      r:50,
      m:Math.PI*50*50, //mass = area
      vx:15,
      vy:30
    }, 
    {
      cx:135,
      cy:-90,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-45,
      vy:60
    }
  ];</span></code></pre></div></div>
    <p>Apply the code above into the example:</p>
<div class="codeParentDiv" style="height:98em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {
      cx:-45,
      cy:-75,
      r:50,
      m:Math.PI*50*50, //mass = area
      vx:15,
      vy:30
    }, 
    {
      cx:135,
      cy:-90,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-45,
      vy:60
    }
  ];

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
    </div></div>
    <p>The canvas should appears as if no changes:</p>
    <iframe id="iframe-chapter_6_2_1-1" class="center" src="chapter_6_2_1.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_6_2_1-1').src+='';">Reload</button>
    <p>If it appears as if no changes, why would we want to put the collision code into the for loop? The answer is : <b>to support multiple circle collisions without repeating the codes!</b></p>
    <p>To test if the canvas really supports multiple circles collision, we may add the third circle into the array:</p>
<div class="codeParentDiv" style="height:106em"><div class="hljs copyborder" style="position:absolute;">   
        <pre><code><span class="hl">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt&lt/canvas&gt;
&lt;script&gt;</span>
<span class="hl">  const circleArray = [
    {
      cx:-45,
      cy:-75,
      r:50,
      m:Math.PI*50*50, //mass = area
      vx:15,
      vy:30
    }, 
    {
      cx:135,
      cy:-90,
      r:30,
      m:Math.PI*30*30, //mass = area
      vx:-45,
      vy:60
    },
    {
      cx:-90,
      cy:180,
      r:40,
      m:Math.PI*40*40, //mass = area
      vx:30,
      vy:-30
    }
  ];

  const canvas = document.getElementById("myCanvas");
  const ctx = canvas.getContext("2d");
  ctx.font="12px sans-serif";
  ctx.textAlign="center";
  const frameRate=60;

  setInterval(function(){
    //circle position update
    for(const c of circleArray){
        c.cx += c.vx * 1 / frameRate;
        c.cy += c.vy * 1 / frameRate;
    }

    //circle check collision : find if d is smaller than (or equals to) r1+r2
    for(let i = 0; i < circleArray.length ; i++){
      const c1 = circleArray[i];
      for(let j = i; j < circleArray.length ; j++){
        const c2 = circleArray[j];
        const dx=c2.cx-c1.cx;
        const dy=c2.cy-c1.cy;
        if(dx * dx + dy * dy <= (c1.r + c2.r)*(c1.r + c2.r)){ //find if d is smaller than (or equals to) r1+r2
          const rel_c2vx = c2.vx - c1.vx;
          const rel_c2vy = c2.vy - c1.vy;
          if(rel_c2vx * dx + rel_c2vy * dy < 0){ //apply collision only when 2 circles are colliding instead of separating
            c1.vx += 2 * dx * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c1.vy += 2 * dy * c2.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vx -= 2 * dx * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
            c2.vy -= 2 * dy * c1.m * (rel_c2vx * dx + rel_c2vy * dy) / (dx * dx + dy * dy) / (c1.m + c2.m);
          }
        }
      }
    }

    //clear all drawings
    ctx.clearRect(0,0,canvas.width,canvas.height);

    //draw x and y axis
    ctx.strokeStyle="lightgray";
    ctx.beginPath();
    ctx.moveTo(0,canvas.height/2);
    ctx.lineTo(canvas.width,canvas.height/2);
    ctx.moveTo(canvas.width/2,0);
    ctx.lineTo(canvas.width/2,canvas.height);
    ctx.stroke();
    ctx.strokeStyle="black";

    //draw border
    ctx.beginPath();
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.stroke();

    //draw circle
    for(let i=0;i < circleArray.length;i++){
        const c=circleArray[i];
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,c.r,0,2*Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillText(c.cx.toFixed(1)+","+c.cy.toFixed(1),canvas.width/2+c.cx,canvas.height/2-c.cy+16);
        ctx.fillStyle=ctx.strokeStyle="blue";
        ctx.moveTo(canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.lineTo(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy,2,0,2*Math.PI);
        ctx.fill();
        ctx.fillText(c.vx.toFixed(1)+","+c.vy.toFixed(1),canvas.width/2+c.cx+c.vx,canvas.height/2-c.cy-c.vy-4);
        ctx.fillStyle=ctx.strokeStyle="gray";
        ctx.fillText("C"+i,canvas.width/2+c.cx,canvas.height/2-c.cy);
        ctx.fillStyle=ctx.strokeStyle="black";
        ctx.beginPath();
        ctx.arc(canvas.width/2+c.cx,canvas.height/2-c.cy,2,0,2*Math.PI);
        ctx.fill();
    }
  },1000/frameRate);</span>
<span class="hl">&lt/script&gt</span></code></pre>
        <div class="dimdiv">
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="showcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
          <code class="dimcode">&nbsp;</code>
        </div>
    </div></div>
    <p>Now the canvas should show 3 circles are colliding then they meet:</p>
    <iframe id="iframe-chapter_6_2_2-1" class="center" src="chapter_6_2_2.html" width="400px" height="400px" frameBorder="0" marginheight="0" marginwidth="0"></iframe>
    <br/><button class="center" onclick="document.getElementById('iframe-chapter_6_2_2-1').src+='';">Reload</button>
    <p>Great! Now you may add circles at the array without adding the collision codes for each circle!</p>
        </div></td>
      </tr>
    </table>
  </body>
  <script src="highlight/highlight.min.js"></script>
  <script>
  document.querySelectorAll('.hl').forEach(el => {
    hljs.highlightElement(el);
  });
  </script>
</html>
